{"docstore/metadata": {"knapsack_expert": {"doc_hash": "01de021f88276e7fdae8dca3db06434cdeceb6a01b5741f6a3f3df39eb4dfba9"}, "lam_expert": {"doc_hash": "be3e2727c71361576bc6dc112bdb0dc81d50f713608fa072c53cdcd90bd0337f"}, "low_autocorrel_expert": {"doc_hash": "ffd4ceb311e9aa6ea1e8940cee0c39f24937f4139e309494f041a78a694db7c0"}, "magic_hexagon_expert": {"doc_hash": "691260b08a7d185664508733a39e23fd965c7cc950bb86974a8b49afd2a59ffb"}, "ppp_expert": {"doc_hash": "0075e66901ef41d74f7e2c26ff20d06008afa16391ade511eebb709248616d5d"}, "rag_config_expert": {"doc_hash": "608fea67ff4b0baf2f3de5e3234a31ddeff141b04c0fce7951aca3101694b76c"}, "ramsey_expert": {"doc_hash": "ad7fa3ed475b712fa480220ca099e79baa3d6fadace98a813e67bd734634cf52"}, "vellino_expert": {"doc_hash": "0bd2ffdfe1c6b5f1b9eb39c783ac121b28e418b1cb1da7e43a4fc93e4767c025"}, "wagner_expert": {"doc_hash": "2ca14162ef307d96e93902c86fe49e64f92ceffe8878eb4298e11b5eab76f58e"}, "word_design_expert": {"doc_hash": "c1859d1bb7496a77459fb1c65dce4e37cec5c3cc5ae795b21e58be58c78c20c9"}, "7a71bd52-5bed-4781-aec2-c3d0a4cfc6b2": {"doc_hash": "01de021f88276e7fdae8dca3db06434cdeceb6a01b5741f6a3f3df39eb4dfba9", "ref_doc_id": "knapsack_expert"}, "b5baaacd-c78d-4b60-90b0-d27d29ec77dc": {"doc_hash": "be3e2727c71361576bc6dc112bdb0dc81d50f713608fa072c53cdcd90bd0337f", "ref_doc_id": "lam_expert"}, "eb92b456-85e6-4a77-8415-dee6a95c8b7e": {"doc_hash": "ffd4ceb311e9aa6ea1e8940cee0c39f24937f4139e309494f041a78a694db7c0", "ref_doc_id": "low_autocorrel_expert"}, "59da8607-d8b4-41f6-a27b-cc441d1f7707": {"doc_hash": "691260b08a7d185664508733a39e23fd965c7cc950bb86974a8b49afd2a59ffb", "ref_doc_id": "magic_hexagon_expert"}, "452d492d-4a7d-4048-9d44-983159b4d8bb": {"doc_hash": "0075e66901ef41d74f7e2c26ff20d06008afa16391ade511eebb709248616d5d", "ref_doc_id": "ppp_expert"}, "da308484-7ddd-4a91-8648-8c661aaeeaf0": {"doc_hash": "608fea67ff4b0baf2f3de5e3234a31ddeff141b04c0fce7951aca3101694b76c", "ref_doc_id": "rag_config_expert"}, "a2832de2-30de-4b1e-af34-9ba313b7b895": {"doc_hash": "ad7fa3ed475b712fa480220ca099e79baa3d6fadace98a813e67bd734634cf52", "ref_doc_id": "ramsey_expert"}, "b2aa7d22-0d18-44fa-bf34-73b38496362e": {"doc_hash": "0bd2ffdfe1c6b5f1b9eb39c783ac121b28e418b1cb1da7e43a4fc93e4767c025", "ref_doc_id": "vellino_expert"}, "2f2a1d0a-4da4-405d-bc1a-560cbc27d264": {"doc_hash": "2ca14162ef307d96e93902c86fe49e64f92ceffe8878eb4298e11b5eab76f58e", "ref_doc_id": "wagner_expert"}, "eba2ea95-038b-4de3-943a-79f06ab574b0": {"doc_hash": "c1859d1bb7496a77459fb1c65dce4e37cec5c3cc5ae795b21e58be58c78c20c9", "ref_doc_id": "word_design_expert"}}, "docstore/data": {"7a71bd52-5bed-4781-aec2-c3d0a4cfc6b2": {"__data__": {"id_": "7a71bd52-5bed-4781-aec2-c3d0a4cfc6b2", "embedding": null, "metadata": {"model_name": "knapsack"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "knapsack_expert", "node_type": "4", "metadata": {"model_name": "knapsack"}, "hash": "01de021f88276e7fdae8dca3db06434cdeceb6a01b5741f6a3f3df39eb4dfba9", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language Essence 1.3\n$ prob133.essence: Knapsack Problem\n \ngiven items new type enum\ngiven weight, gain : function (total) items --> int\ngiven capacity : int\nfind picked : set of items\nmaximising sum i in picked . gain(i)\nsuch that (sum i in picked . weight(i)) <= capacity\n            ======\n            Description:\n            ---------\n            name: 0/1 Knapsack Problem\n\ndescription: The 0/1 Knapsack Problem is a classic problem in combinatorial optimization. It involves finding the optimal subset of items to include in a knapsack of limited capacity, such that the total value of the selected items is maximized.\n\nvariables: picked \u2208 2^items\nThe decision variable picked is a set of items, where each item is either selected (included in the knapsack) or not selected.\n\nconstraints: \u2211(i \u2208 picked) weight(i) \u2264 capacity\nThe constraints ensure that the total weight of the selected items does not exceed the knapsack's capacity.\n\nobjective: maximize \u2211(i \u2208 picked) gain(i)\nThe objective is to maximize the total value (gain) of the selected items.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1100, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b5baaacd-c78d-4b60-90b0-d27d29ec77dc": {"__data__": {"id_": "b5baaacd-c78d-4b60-90b0-d27d29ec77dc", "embedding": null, "metadata": {"model_name": "lam"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "lam_expert", "node_type": "4", "metadata": {"model_name": "lam"}, "hash": "be3e2727c71361576bc6dc112bdb0dc81d50f713608fa072c53cdcd90bd0337f", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language Essence 1.3\n$ prob025.essence: Lam's Problem\n$ Problem details available at http://www.csplib.org/Problems/prob025/\n \ngiven indexSize: int\n \nletting Index be new type of size indexSize\n \nfind m: matrix indexed by [Index,Index] of bool\n \nsuch that\n    forAll r : Index\n        . (sum c : Index . toInt(!m[r,c])) = 11,\n    forAll c : Index\n        . (sum r : Index . toInt(!m[r,c])) = 11,\n    forAll r1,r2 : Index , r1 != r2\n        . (sum c : Index . toInt(!(m[r1,c] \\/ m[r2,c]))) = 1\n\n            ======\n            Description:\n            ---------\n            name: Lam's Problem\n\ndescription: Lam's Problem is a classic constraint satisfaction problem that involves finding a binary matrix that satisfies certain constraints. The problem is to find a matrix where each row and column sums up to 11, and for any two distinct rows, there is exactly one column where both rows have a 1.\n\nvariables: m: matrix indexed by [Index,Index] of bool\nThe decision variable is a binary matrix m, where m[r,c] represents the value at row r and column c.\n\nconstraints: \n\u2200r \u2208 Index: \u2211c \u2208 Index toInt(!m[r,c]) = 11, \n\u2200c \u2208 Index: \u2211r \u2208 Index toInt(!m[r,c]) = 11, \n\u2200r1, r2 \u2208 Index, r1 \u2260 r2: \u2211c \u2208 Index toInt(!(m[r1,c] \\/ m[r2,c])) = 1\nThe constraints are: \n- Each row sums up to 11.\n- Each column sums up to 11.\n- For any two distinct rows, there is exactly one column where both rows have a 1.\n\nobjective: There is no objective function to minimize or maximize in this problem. The goal is to find a feasible solution that satisfies all the constraints.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1591, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "eb92b456-85e6-4a77-8415-dee6a95c8b7e": {"__data__": {"id_": "eb92b456-85e6-4a77-8415-dee6a95c8b7e", "embedding": null, "metadata": {"model_name": "low_autocorrel"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "low_autocorrel_expert", "node_type": "4", "metadata": {"model_name": "low_autocorrel"}, "hash": "ffd4ceb311e9aa6ea1e8940cee0c39f24937f4139e309494f041a78a694db7c0", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language Essence 1.3\n$ prob005.essence: Low Autocorrellation Binary Sequences\n$ Problem details available at http://www.csplib.org/Problems/prob005/\n \ngiven n : int(1..)\n \nfind seq : function (total) int(1..n) --> int(-1,1)\n \nminimising sum k : int(1..n) . (sum i : int(1..n-k) . seq(i) * seq(i+k)) ** 2\n            ======\n            Description:\n            ---------\n            name: Low Autocorrelation Binary Sequences\n\ndescription: The Low Autocorrelation Binary Sequences problem is a classic constraint programming problem that involves finding a binary sequence of length n with the lowest possible autocorrelation. Autocorrelation measures the similarity between a sequence and its shifted versions. In this problem, the goal is to find a sequence with minimal autocorrelation, which has applications in various fields such as signal processing, coding theory, and cryptography.\n\nvariables: seq(i) \u2208 {-1, 1} for i = 1 to n\nThe decision variables are the elements of the binary sequence seq, where each element seq(i) can take a value of either -1 or 1.\n\nconstraints: None\nThere are no explicit constraints in this model, as the problem is solely defined by the objective function.\n\nobjective: Minimize \u2211(k=1 to n) (\u2211(i=1 to n-k) seq(i) * seq(i+k))^2\nThe objective is to minimize the sum of the squared autocorrelations of the sequence at all possible shifts k, where k ranges from 1 to n. The autocorrelation at shift k is calculated as the sum of the products of corresponding elements in the original sequence and its k-shifted version.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1593, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "59da8607-d8b4-41f6-a27b-cc441d1f7707": {"__data__": {"id_": "59da8607-d8b4-41f6-a27b-cc441d1f7707", "embedding": null, "metadata": {"model_name": "magic_hexagon"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "magic_hexagon_expert", "node_type": "4", "metadata": {"model_name": "magic_hexagon"}, "hash": "691260b08a7d185664508733a39e23fd965c7cc950bb86974a8b49afd2a59ffb", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language ESSENCE 1.2.0\n$ prob023.essence: Magic Hexagon\n$ Problem details available at http://www.csplib.org/Problems/prob023/\n$ 03 September 2007\n$\n \n$ d: the diameter of the hexagon (length of the longest row)\ngiven d : int(1..)\n \n$ d must be an odd integer\nwhere d % 2 = 1\n \n$ o: the order of the hexagon (length of the shortest row)\n$ maxval: the maximum value that will appear in the hexagon\n$ maxsum: the maximum value that a row could sum to\n$ Value: the domain consisting of the integers contained in the hexagon\nletting o be d/2 + 1,\n        maxval be 3 * o**2 - 3 * o + 1,\n        maxsum be sum i : int(maxval + 1 - d..maxval) . i,\n        Value be domain int(1..maxval)\n \n$ hexagon: the hexagon is represented by a matrix. for any row i, we are only\n$          interested in the first d - |d/2 + 1 - i| elements of the row\n$ s: the magic number that all rows and diagonals sum to\nfind hexagon : matrix indexed by [int(1..d),int(1..d)] of Value,\n     s : int(1..maxsum)\n \nsuch that\n$ all elements are different (and therefore all values are included)\n    forAll r1,r2 : int(1..d) . forAll i1 : int(1..d - |o - r1|) .\n        forAll i2 : int(1..d - |o - r2|) . r1 != r2 \\/ i1 != i2 ->\n            hexagon[r1,i1] != hexagon[r2,i2],\n$ all rows sum to s\n    forAll r : int(1..d) . (sum i : int(1..d - |o - r|) . hexagon[r,i]) = s,\n$ all right-sloping diagonals sum to s\n    forAll r : int(1..d) . (sum i : int(1..d - |o - r|) .\n        hexagon[i + max({0,o-r}), r - max({0,o-(i + max({0,o-r}))})]) = s,\n$ all left-sloping diagonals sum to s\n    forAll r : int(1..d) . (sum i : int(1..d - |o - r|) .\n        hexagon[i + max({0,r-o}), r - max({0,(i + max({0,r-o}))-o})]) = s\n            ======\n            Description:\n            ---------\n            name: Magic Hexagon\n\ndescription: The Magic Hexagon problem is a classic constraint satisfaction problem where we need to fill a hexagonal grid of size d with integers from 1 to maxval, such that each row, right-sloping diagonal, and left-sloping diagonal sums up to a magic number s.\n\nvariables: hexagon[r,i], s\n\nhexagon[r,i] represents the value at row r and column i in the hexagonal grid, and s is the magic number that all rows and diagonals sum to.\n\nconstraints: \nhexagon[r1,i1] != hexagon[r2,i2] for r1 != r2 or i1 != i2, \nsum(hexagon[r,i]) = s for all r, \nsum(hexagon[i + max({0,o-r}), r - max({0,o-(i + max({0,o-r}))})]) = s for all r, \nsum(hexagon[i + max({0,r-o}), r - max({0,(i + max({0,r-o}))-o})]) = s for all r\n\nThe first constraint ensures that all elements in the hexagonal grid are distinct. The second constraint ensures that the sum of each row is equal to the magic number s. The third and fourth constraints ensure that the sum of each right-sloping and left-sloping diagonal is equal to the magic number s, respectively.\n\nobjective: There is no objective function to minimize or maximize in this problem. The goal is to find a feasible solution that satisfies all the constraints.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3004, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "452d492d-4a7d-4048-9d44-983159b4d8bb": {"__data__": {"id_": "452d492d-4a7d-4048-9d44-983159b4d8bb", "embedding": null, "metadata": {"model_name": "ppp"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ppp_expert", "node_type": "4", "metadata": {"model_name": "ppp"}, "hash": "0075e66901ef41d74f7e2c26ff20d06008afa16391ade511eebb709248616d5d", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language Essence 1.3\n$ prob013.essence: Progressive Party Problem\n$ Problem details available at http://www.csplib.org/Problems/prob013/\n \ngiven n_boats, n_periods : int(1..)\n \nletting Boat be domain int(1..n_boats)\n \ngiven capacity, crew : function (total) Boat --> int(1..)\n \nfind hosts : set (minSize 1) of Boat,\n     sched : set (size n_periods) of partition from Boat\n \nminimising |hosts|\n \n$ Hosts remain the same throughout the schedule\nsuch that\n    forAll p in sched . |parts(p)| = |hosts| /\\\n    forAll part in parts(p) . |part intersect hosts| = 1\n \n$ Hosts have the capacity to support the visiting crews\nsuch that forAll p in sched . forAll h in hosts .\n    (sum b in party(h,p) . crew(b)) <= capacity(h)\n \nsuch that allDiff([ (i, j)\n                  | p <- sched\n                  , part <- p\n                  , {i,j} <- powerSet(part)\n                  ])\n            ======\n            Description:\n            ---------\n            name: Progressive Party Problem\n\ndescription: The Progressive Party Problem is a classic constraint satisfaction problem that involves scheduling a set of boats to host parties over a certain number of periods. Each boat has a limited capacity and a crew, and each party has a certain number of guests. The goal is to find a schedule that assigns each boat to host a party in each period, such that each boat has the capacity to support the visiting crews, and the number of hosts is minimized.\n\nvariables: hosts \u2208 \u2118(Boat), sched \u2208 \u2118(Partition(Boat))\n\nThe decision variables are `hosts`, which represents the set of boats that will host parties, and `sched`, which represents the schedule of parties assigned to each boat over the periods.\n\nconstraints: \n|parts(p)| = |hosts| \u2200p \u2208 sched, \n|part \u2229 hosts| = 1 \u2200part \u2208 p, p \u2208 sched, \n(\u2211b \u2208 party(h,p) . crew(b)) \u2264 capacity(h) \u2200h \u2208 hosts, p \u2208 sched, \nallDiff({(i, j) | p \u2208 sched, part \u2208 p, {i,j} \u2208 \u2118(part)})\n\nThe constraints ensure that: \n- each period has the same number of parties as the number of hosts, \n- each party is assigned to exactly one host, \n- the total crew of the parties assigned to a host does not exceed the host's capacity, \n- and each pair of boats is assigned to different parties in each period.\n\nobjective: minimize |hosts|\n\nThe objective is to minimize the number of hosts (boats) needed to schedule all the parties.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2382, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "da308484-7ddd-4a91-8648-8c661aaeeaf0": {"__data__": {"id_": "da308484-7ddd-4a91-8648-8c661aaeeaf0", "embedding": null, "metadata": {"model_name": "rag_config"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "rag_config_expert", "node_type": "4", "metadata": {"model_name": "rag_config"}, "hash": "608fea67ff4b0baf2f3de5e3234a31ddeff141b04c0fce7951aca3101694b76c", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language Essence 1.3\n$ prob031.essence: Rack Configuration Problem\n$ Problem details available at http://www.csplib.org/Problems/prob031/\n \n$ We are using the problem description from the following paper very closely here.\n$ \"Symmetry Breaking in a Rack Configuration Problem\" Zeynep K\u0131z\u0131ltan and Brahim Hnich\n \n \n \n$ The rack configuration problem consists of plugging a set of electronic cards\n$ into racks with electronic connectors.\ngiven nbRacks : int(1..)\nletting Rack be new type of size nbRacks\n \n$ Each card belongs to a certain card type.\ngiven nbTypes : int(1..)\nletting Type be domain int(1..nbTypes)\n \n$ A card type is characterised by the power it requires, ...\ngiven requiredPower : function (total) Type --> int(1..)\n \n$ ... and a demand, which designates how many cards of that type have to be plugged.\ngiven demand : function (total) Type --> int(1..)\n \n \n$ In order to plug a card into a rack, the rack needs to use a rack model.\ngiven nbModels : int\nletting Model be domain int(1..nbModels)\n \n$ Each rack model is characterised by the maximal power it can supply, its number of connectors, and its price.\ngiven maxPower      : function (total) Model --> int(1..)\ngiven maxConnectors : function (total) Model --> int(1..)\ngiven price         : function (total) Model --> int(1..)\n \n$ A rack model can be used by any rack.\n$ Each card plugged into a rack uses a connector.\n$ The problem is to decide how many of the available racks are needed,\n$ and which rack models the racks use in order to plug all the cards\n$ such that the total price is minimised.\n \nfind configuration :\n        function Rack -->\n            $ the model for this rack\n            ( Model\n            $ for each type, the number of cards of that type\n            , function (total) Type --> int(0..max(range(maxConnectors)))\n            )\n \n \n$ The constraints of the problem and the cost function can be summarised as the following:\n \n$ The connector-capacity constraint:\n$ the number of cards plugged into a rack r\n$ must not exceed the number of connectors of the rack model used by r.\nsuch that\n    forAll (rack, (model, counts)) in configuration .\n        sum([ num | (ty, num) <- counts ]) <= maxConnectors(model)\n \n$ The power-capacity constraint:\n$ the total power of the cards plugged into a rack r\n$ must not exceed the power of the rack model used by r.\nsuch that\n    forAll (rack, (model, counts)) in configuration .\n        sum([ requiredPower(ty) * num | (ty, num) <- counts ]) <= maxPower(model)\n \n$ The demand constraint: all the cards have to be plugged into some rack.\nsuch that\n    forAll (ty, tyDemand) in demand .\n        tyDemand <= sum([ num\n                        | (rack, (model, counts)) <- configuration\n                        , (ty2, num) <- counts\n                        , ty = ty2\n                        ])\n \n$ The cost function is the sum of the prices of the rack models used by all the racks needed.\nfind totalCost : int(0.. |Rack| * |Model| * max(range(price)) )\nsuch that totalCost = sum (rack, (model, counts)) in configuration . price(model)\nminimising totalCost\n            ======\n            Description:\n            ---------\n            name: Rack Configuration Problem\n\ndescription: The Rack Configuration Problem is a classic constraint programming problem that involves configuring racks to plug in electronic cards of different types. Each card type has a specific power requirement and demand, and each rack model has a limited power supply, number of connectors, and price. The goal is to determine the minimum-cost configuration of racks and rack models that can accommodate all the cards while satisfying the power and connector capacity constraints.\n\nvariables: configuration[rack] = (model, counts), where configuration is a function that assigns a rack model and a set of card counts to each rack.\n\nThe decision variables are the rack models and the number of cards of each type plugged into each rack.\n\nconstraints: \n1. sum([ num | (ty, num) <- counts ]) <= maxConnectors(model) (connector-capacity constraint)\n2. sum([ requiredPower(ty) * num | (ty, num) <- counts ]) <= maxPower(model) (power-capacity constraint)\n3. tyDemand <= sum([ num | (rack, (model, counts)) <- configuration, (ty2, num) <- counts, ty = ty2 ]) (demand constraint)\n\nThe constraints ensure that each rack does not exceed its connector capacity, power capacity, and that all cards are plugged into some rack.\n\nobjective: minimize totalCost = sum (rack, (model, counts)) in configuration . price(model)\n\nThe objective is to minimize the total cost of the rack models used.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4635, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a2832de2-30de-4b1e-af34-9ba313b7b895": {"__data__": {"id_": "a2832de2-30de-4b1e-af34-9ba313b7b895", "embedding": null, "metadata": {"model_name": "ramsey"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ramsey_expert", "node_type": "4", "metadata": {"model_name": "ramsey"}, "hash": "ad7fa3ed475b712fa480220ca099e79baa3d6fadace98a813e67bd734634cf52", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language Essence 1.3\n \n$ The Ramsey number R(k,l) is the smallest number such that\n$ if we two-colour the edges of complete graph of this size,\n$ there always exists a monochromatic subgraph of either k or l nodes.\n \n$ In other words (from Wikipedia):\n$ The Ramsey number, R(k,l), gives the solution to the party problem,\n$ which asks the minimum number of guests, R(k,l), that must be invited\n$ so that at least k will know each other\n$      or at least l will not know each other.\n \n$ Here, we are modelling the Ramsey-graph problem which is the problem of finding counter-examples.\n$ For a given k,l, and num_vertices: find a colouring of the complete graph\n$ which does not have a blue-subgraph nor a red-subgraph.\n \ngiven k, l, num_vertices : int\n \n$ due to symmetry R(k, l) = R(l,k)\nwhere k <= l\n \n$ complete graph, to we can calculate the number of edges\nletting num_edges be num_vertices * (num_vertices - 1)\n \n$ we are two-colouring\nletting Colour be new type enum {red, blue}\n \nletting Vertex be domain int(1..num_vertices)\n \nfind graph : function (size num_edges) (Vertex, Vertex) --> Colour\n \n \n$ the graph is complete\nsuch that\n    forAll i,j : Vertex . i < j ->\n        (i,j) in defined(graph) /\\ graph((i,j)) = graph((j,i)),\n    forAll i : Vertex .\n        !((i,i) in defined(graph))\n \n \n$ there isn't a red-subgraph of size k\nsuch that\n    forAll subgraph_vertices : set (size k) of Vertex .\n        !(forAll {i,j} subsetEq subgraph_vertices . graph((i,j)) = red)\n \n \n$ there isn't a blue-subgraph of size l\nsuch that\n    forAll subgraph_vertices : set (size l) of Vertex .\n        !(forAll {i,j} subsetEq subgraph_vertices . graph((i,j)) = blue)\n            ======\n            Description:\n            ---------\n            name: Ramsey Graph Problem\n\ndescription: The Ramsey Graph Problem is a classic problem in graph theory and constraint programming. It involves finding a two-coloring of a complete graph with a given number of vertices, such that there is no monochromatic subgraph of a certain size. In other words, the problem is to find a coloring of the edges of a complete graph, using two colors (red and blue), such that there is no subgraph with a certain number of vertices that is entirely red or entirely blue.\n\nvariables: graph: (Vertex, Vertex) \u2192 Colour\n\nThe decision variable is a function graph that assigns a color (red or blue) to each edge of the complete graph. The domain of the function is the set of all possible edges in the graph, represented as pairs of vertices.\n\nconstraints: \n1. \u2200i, j \u2208 Vertex . i < j \u2192 (i, j) \u2208 defined(graph) \u2227 graph((i, j)) = graph((j, i))\n2. \u2200i \u2208 Vertex . \u00ac((i, i) \u2208 defined(graph))\n3. \u2200subgraph_vertices \u2286 Vertex . |subgraph_vertices| = k \u2192 \u00ac(\u2200{i, j} \u2286 subgraph_vertices . graph((i, j)) = red)\n4. \u2200subgraph_vertices \u2286 Vertex . |subgraph_vertices| = l \u2192 \u00ac(\u2200{i, j} \u2286 subgraph_vertices . graph((i, j)) = blue)\n\nThe constraints ensure that:\n- The graph is complete and undirected (constraints 1 and 2).\n- There is no red subgraph of size k (constraint 3).\n- There is no blue subgraph of size l (constraint 4).\n\nobjective: The objective of the problem is to find a feasible solution, i.e., a coloring of the graph that satisfies all the constraints. There is no objective function to minimize or maximize.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3317, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b2aa7d22-0d18-44fa-bf34-73b38496362e": {"__data__": {"id_": "b2aa7d22-0d18-44fa-bf34-73b38496362e", "embedding": null, "metadata": {"model_name": "vellino"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "vellino_expert", "node_type": "4", "metadata": {"model_name": "vellino"}, "hash": "0bd2ffdfe1c6b5f1b9eb39c783ac121b28e418b1cb1da7e43a4fc93e4767c025", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language ESSENCE 1.2.0\n$ prob116.essence: Vellino's Problem\n$ Problem details available in:\n$   The OPL Optimization Programming Language\n$   Pascal Van Hentenryck\n$   MIT Press, January 1999.\n$\n$ 27 July 2007\n$\n \ngiven maxMaterial : int\n \n$ Material: there are five different types of materials\n$ Colour: there are three different types of bin, distinguished by colour\nletting Material be new type enum {glass,plastic,steel,wood,copper},\n        Colour be new type enum {red,green,blue}\n \n$ quantity: the amount of each material that is required to be placed in bins\n$ capacity: each bin type (colour) has a certain capacity\ngiven quantity : function (total) Material --> int(0..),\n      capacity : function (total) Colour --> int(0..)\n \n$ Bin: bins are represented by an unnamed type. the number of values is the same\n$      as the total amount of material that is required\nletting Bin be new type of size (sum m : Material . quantity(m))\n \n$ colour: each bin is assigned a colour\n$ contents: the contents of each bin is a multiset of materials\nfind colour : function Bin --> Colour,\n     $ The size of each mset returned by contents is <= some value returned by capacity (given)\n     contents : function Bin --> mset (maxOccur maxMaterial, maxSize max(range(capacity))) of Material\n \n$ minimise the number of bins that have colours & materials assigned to them\nminimising |defined(colour)|\n \nsuch that\n$ every bin that has a colour, must also have a contents, and vice versa\n    forAll b : Bin . b in defined(colour) <-> b in defined(contents),\n$ the correct amount of each material is spread across all the bins\n    forAll m : Material . (sum b in defined(contents) . freq(contents(b),m))\n                          = quantity(m),\n$ the amount of material in each bin does not exceed its capacity\n    forAll b in defined(colour) . |contents(b)| <= capacity(colour(b)),\n$ red bins cannot contain plastic or steel\n    forAll b in defined(colour) . colour(b) = red ->\n                                   !(plastic in contents(b)) /\\\n                                   !(steel in contents(b)),\n$ blue bins cannot contain wood or plastic\n    forAll b in defined(colour) . colour(b) = blue ->\n                                   !(wood in contents(b)) /\\\n                                   !(plastic in contents(b)),\n$ green bins cannot contain steel or glass\n    forAll b in defined(colour) . colour(b) = green ->\n                                   !(steel in contents(b)) /\\\n                                   !(glass in contents(b)),\n$ red bins contain at most one wooden component\n    forAll b in defined(colour) . colour(b) = red ->\n                                   freq(contents(b),wood) <= 1,\n$ green bins contain at most two wooden components\n    forAll b in defined(colour) . colour(b) = green ->\n                                   freq(contents(b),wood) <= 2,\n$ wood requires plastic\n    forAll b in defined(colour) . wood in contents(b) ->\n                                   plastic in contents(b),\n$ glass excludes copper\n    forAll b in defined(colour) . glass in contents(b) ->\n                                   !(copper in contents(b)),\n$ copper excludes plastic\n    forAll b in defined(colour) . copper in contents(b) ->\n                                   !(plastic in contents(b))\n            ======\n            Description:\n            ---------\n            name: Vellino's Problem\n\ndescription: Vellino's Problem is a classic constraint satisfaction problem that involves assigning materials to bins of different colors, subject to various constraints on the capacity of the bins, the compatibility of materials with bin colors, and the co-occurrence of certain materials.\n\nvariables: colour: Bin \u2192 Colour, contents: Bin \u2192 mset(Material)\n\nThe decision variables are `colour` and `contents`. `colour` assigns a color (red, green, or blue) to each bin, and `contents` assigns a multiset of materials (glass, plastic, steel, wood, or copper) to each bin.\n\nconstraints: \nb \u2208 defined(colour) \u2194 b \u2208 defined(contents) \u2200b \u2208 Bin\n\u2211b \u2208 defined(contents) freq(contents(b), m) = quantity(m) \u2200m \u2208 Material\n|contents(b)| \u2264 capacity(colour(b)) \u2200b \u2208 defined(colour)\ncolour(b) = red \u2192 \u00ac(plastic \u2208 contents(b)) \u2227 \u00ac(steel \u2208 contents(b)) \u2200b \u2208 defined(colour)\ncolour(b) = blue \u2192 \u00ac(wood \u2208 contents(b)) \u2227 \u00ac(plastic \u2208 contents(b)) \u2200b \u2208 defined(colour)\ncolour(b) = green \u2192 \u00ac(steel \u2208 contents(b)) \u2227 \u00ac(glass \u2208 contents(b)) \u2200b \u2208 defined(colour)\ncolour(b) = red \u2192 freq(contents(b), wood) \u2264 1 \u2200b \u2208 defined(colour)\ncolour(b) = green \u2192 freq(contents(b), wood) \u2264 2 \u2200b \u2208 defined(colour)\nwood \u2208 contents(b) \u2192 plastic \u2208 contents(b) \u2200b \u2208 defined(colour)\nglass \u2208 contents(b) \u2192 \u00ac(copper \u2208 contents(b)) \u2200b \u2208 defined(colour)\ncopper \u2208 contents(b) \u2192 \u00ac(plastic \u2208 contents(b)) \u2200b \u2208 defined(colour)\n\nThe constraints ensure that each bin has a color if and only if it has contents, the total amount of each material is spread across all bins, the capacity of each bin is not exceeded, and the various material-color and material-material incompatibilities are respected.\n\nobjective: minimize |defined(colour)|\n\nThe objective is to minimize the number of bins that have colors and materials assigned to them.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 5220, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2f2a1d0a-4da4-405d-bc1a-560cbc27d264": {"__data__": {"id_": "2f2a1d0a-4da4-405d-bc1a-560cbc27d264", "embedding": null, "metadata": {"model_name": "wagner"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "wagner_expert", "node_type": "4", "metadata": {"model_name": "wagner"}, "hash": "2ca14162ef307d96e93902c86fe49e64f92ceffe8878eb4298e11b5eab76f58e", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language Essence 1.3\n \n$ ** Updates **\n$ 2021/08/04 - The new model 'DistributionWagnerWhitin-partialfunc.essence' performances\n$              signficantly better in practice.\n \n$ Problem Wagner-Whitin Distribution\n$\n$ Problem details available at http://www.csplib.org/Problems/prob040/\n$\n$ Essence model by Andrew Martin\n$\n$ Licenced under CC-BY-4.0 : http://creativecommons.org/licenses/by/4.0/\n \n$ in this model, rather than define multiple levels, children of each node are defined explicitly\n \ngiven numNodes : int(1..)\n \n$ leaves are always first numLeaves nodes\n$ leaves cannot have any children\ngiven numLeaves : int(1..)\n \n$ period 0 is empty, all stock is 0\ngiven numPeriods : int(1..)\n \n$ used to provide bound to output\ngiven maxStock : int(1..)\n \nletting dNodes be domain int(1..numNodes)\nletting dLeaves be domain int(1..numLeaves)\nletting dAllPeriods be domain int(0..numPeriods)\nletting dPeriods be domain int(1..numPeriods)\n \ngiven holdingCost : matrix indexed by [dNodes] of int(0..)\n \ngiven procCost : matrix indexed by [dNodes] of int(0..)\n \ngiven demand : matrix indexed by [dLeaves, dPeriods] of int(0..)\n \n$ used to determine where supply comes goes to\ngiven children : matrix indexed by [dNodes] of set of dNodes\n \nfind orders : matrix indexed by [dNodes, dPeriods] of int(0..maxStock)\n \n$ AUX find statement\nfind stock : matrix indexed by [dNodes, dAllPeriods] of int(0..maxStock)\n \n$ minimising the cost\n$ holding*stock per period per node plus proc if any orders were placed per period per node\nminimising (sum t : dPeriods . (sum i : dNodes . (holdingCost[i] * stock[i][t] + procCost[i] * toInt(orders[i][t] > 0))))\n \n \nsuch that\n \n$ stock starts at 0\n    forAll i : dNodes .\n        stock[i][0] = 0\n,\n$ non-leaf constraints - orders coming from children must be fulfilled\n    forAll t : dPeriods .\n        forAll i : int(numLeaves+1..numNodes) .\n            stock[i][t] = stock[i][t-1] + orders[i][t] - (sum m in children[i] . orders[m][t])\n,\n$ leaf constraints - demands must be fullfilled\n    forAll t : dPeriods .\n        forAll i : dLeaves .\n            stock[i][t] = stock[i][t-1] + orders[i][t] - demand[i][t]\n            ======\n            Description:\n            ---------\n            name: Wagner-Whitin Distribution Problem\n\ndescription: The Wagner-Whitin Distribution Problem is a classic problem in inventory management and supply chain management. It involves finding the optimal ordering policy for a set of nodes in a distribution network, where each node has a demand for a product over a set of periods. The goal is to minimize the total cost of holding inventory and processing orders, while ensuring that demand is met at each node.\n\nvariables: orders: matrix indexed by [dNodes, dPeriods] of int(0..maxStock), stock: matrix indexed by [dNodes, dAllPeriods] of int(0..maxStock)\n\nThe decision variables are orders and stock. orders[i][t] represents the quantity of the product ordered at node i in period t, and stock[i][t] represents the inventory level at node i at the end of period t.\n\nconstraints: \nstock[i][0] = 0 \u2200 i \u2208 dNodes, \nstock[i][t] = stock[i][t-1] + orders[i][t] - \u2211(m \u2208 children[i]) orders[m][t] \u2200 t \u2208 dPeriods, \u2200 i \u2208 int(numLeaves+1..numNodes), \nstock[i][t] = stock[i][t-1] + orders[i][t] - demand[i][t] \u2200 t \u2208 dPeriods, \u2200 i \u2208 dLeaves\n\nThe constraints ensure that: \n- the initial inventory level at each node is 0, \n- the inventory level at each non-leaf node is updated based on the orders received from its children and the orders placed by the node itself, \n- the inventory level at each leaf node is updated based on the demand and the orders placed by the node itself.\n\nobjective: minimize \u2211(t \u2208 dPeriods) \u2211(i \u2208 dNodes) (holdingCost[i] * stock[i][t] + procCost[i] * toInt(orders[i][t] > 0))\n\nThe objective is to minimize the total cost, which is the sum of the holding cost and the processing cost over all nodes and periods. The holding cost is proportional to the inventory level, and the processing cost is incurred whenever an order is placed.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4061, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "eba2ea95-038b-4de3-943a-79f06ab574b0": {"__data__": {"id_": "eba2ea95-038b-4de3-943a-79f06ab574b0", "embedding": null, "metadata": {"model_name": "word_design"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "word_design_expert", "node_type": "4", "metadata": {"model_name": "word_design"}, "hash": "c1859d1bb7496a77459fb1c65dce4e37cec5c3cc5ae795b21e58be58c78c20c9", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language Essence 1.3\n$ prob033.essence: Word Design for DNA Computing on Surfaces\n$ Problem details available at http://www.csplib.org/Problems/prob033/\n \nletting Base be new type enum {A,C,G,T},\n        Index be domain int(1..8)\n \n$ Notice: The problem specification states that we are trying to find a set of words.\n$ We take this literally, and do not allow repeated words.\n \nfind words : set of function (total) Index --> Base\n \nmaximising |words|\n \nsuch that\n \n    $ Each word in S has 4 symbols from (C, G)\n    forAll w in words . |preImage(w,C)| + |preImage(w,G)| = 4,\n \n    $ Each pair of words in S differ in at least 4 positions\n    forAll {w1,w2} subsetEq words .\n        (sum i : Index . toInt(w1(i) != w2(i))) >= 4,\n \n    forAll {w1,w2} subsetEq words .\n        (sum i : Index .\n            $\n            $ To decide whether they are identical at index i, we need to inspect the values of w1(9-i) and w2(i).\n            $ This is because w1 is reversed, and w2 is the Watson-Crick complement.\n            $\n            $ Watson-Crick complementing is implemented by listing a set of allowed pairs.\n            $ If the pair is a member of the set of allowed pairs, they are identical.\n            $\n            $ We require that they are not identical (hence the negation) in at least 4 positions.\n            $\n            toInt(! ((w1(9-i), w2(i)) in {(A,T), (C,G), (G,C), (T,A)}) )\n        ) >= 4\n            ======\n            Description:\n            ---------\n            name: Word Design for DNA Computing on Surfaces\n\ndescription: This problem involves designing a set of words (sequences of DNA bases) that satisfy certain constraints, such as having a specific number of certain bases, differing from each other in at least a certain number of positions, and not being identical to their Watson-Crick complements in at least a certain number of positions. The goal is to find the largest possible set of such words.\n\nvariables: words: {w | w: Index \u2192 Base}\n\nThe decision variable is a set of functions, where each function represents a word of 8 DNA bases (A, C, G, or T), indexed from 1 to 8.\n\nconstraints: \n1. \u2200w \u2208 words. |{i | w(i) = C}| + |{i | w(i) = G}| = 4\nEach word in the set has exactly 4 bases that are either C or G.\n\n2. \u2200w1, w2 \u2208 words. \u2211[i \u2208 Index](w1(i) \u2260 w2(i)) \u2265 4\nEach pair of words in the set differs in at least 4 positions.\n\n3. \u2200w1, w2 \u2208 words. \u2211[i \u2208 Index](w1(9-i), w2(i)) \u2209 {(A,T), (C,G), (G,C), (T,A)} \u2265 4\nEach pair of words in the set is not identical to its Watson-Crick complement in at least 4 positions.\n\nobjective: maximize |words|\n\nThe objective is to maximize the size of the set of words that satisfy the constraints.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2718, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"knapsack_expert": {"node_ids": ["7a71bd52-5bed-4781-aec2-c3d0a4cfc6b2"], "metadata": {"model_name": "knapsack"}}, "lam_expert": {"node_ids": ["b5baaacd-c78d-4b60-90b0-d27d29ec77dc"], "metadata": {"model_name": "lam"}}, "low_autocorrel_expert": {"node_ids": ["eb92b456-85e6-4a77-8415-dee6a95c8b7e"], "metadata": {"model_name": "low_autocorrel"}}, "magic_hexagon_expert": {"node_ids": ["59da8607-d8b4-41f6-a27b-cc441d1f7707"], "metadata": {"model_name": "magic_hexagon"}}, "ppp_expert": {"node_ids": ["452d492d-4a7d-4048-9d44-983159b4d8bb"], "metadata": {"model_name": "ppp"}}, "rag_config_expert": {"node_ids": ["da308484-7ddd-4a91-8648-8c661aaeeaf0"], "metadata": {"model_name": "rag_config"}}, "ramsey_expert": {"node_ids": ["a2832de2-30de-4b1e-af34-9ba313b7b895"], "metadata": {"model_name": "ramsey"}}, "vellino_expert": {"node_ids": ["b2aa7d22-0d18-44fa-bf34-73b38496362e"], "metadata": {"model_name": "vellino"}}, "wagner_expert": {"node_ids": ["2f2a1d0a-4da4-405d-bc1a-560cbc27d264"], "metadata": {"model_name": "wagner"}}, "word_design_expert": {"node_ids": ["eba2ea95-038b-4de3-943a-79f06ab574b0"], "metadata": {"model_name": "word_design"}}}}