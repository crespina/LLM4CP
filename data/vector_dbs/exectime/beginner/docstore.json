{"docstore/metadata": {"knapsack_beginner": {"doc_hash": "1599698582e5ec224f81f8b2586650f8a97784dff7b6caec4e1a46e022f03422"}, "lam_beginner": {"doc_hash": "e594eaff09d6995842be3528ce385a1ea384ec6d85a20f5e410b2d8efc2e7f97"}, "low_autocorrel_beginner": {"doc_hash": "a235c0bd3b4375e34c6d700ac37ac83743822eee9ba34b210dd4acaa9f2c01c9"}, "magic_hexagon_beginner": {"doc_hash": "b61e8c215a811c4b4f8f7a79043a1a698842aa701d3175314dba21bcc51cb532"}, "ppp_beginner": {"doc_hash": "f6404c3249fbcb43b15ca46777f429e29941dd419e1efdd37cf789f4d16fb81d"}, "rag_config_beginner": {"doc_hash": "d6c755db8119fe5694cfd96a2865869431bb4993666f5acc6a7aadfbb81739f5"}, "ramsey_beginner": {"doc_hash": "ea711de294a33f2139a4eab5f2661208257fff6e7455a389d0f87248d1eb2082"}, "vellino_beginner": {"doc_hash": "19e82e6f4880f6b5c41e8440560beae90dda5fb7398aa20285037cc6702f7a8a"}, "wagner_beginner": {"doc_hash": "37381bd81adebc0e44ea8846ffe06df3436eaaca9d177c5cdd0fcaa6a30be29b"}, "word_design_beginner": {"doc_hash": "3f91c3ead95f5cc3ad0d39d7b07436e0b763cf8b9e1a34b2a8712fecdb331e13"}, "7fde722a-0268-4c34-b9f6-2d365b45b20c": {"doc_hash": "1599698582e5ec224f81f8b2586650f8a97784dff7b6caec4e1a46e022f03422", "ref_doc_id": "knapsack_beginner"}, "41221a24-d0a6-46be-966d-86d07aa6ff19": {"doc_hash": "e594eaff09d6995842be3528ce385a1ea384ec6d85a20f5e410b2d8efc2e7f97", "ref_doc_id": "lam_beginner"}, "efe2dce1-3f8e-474c-ac04-f0b7d775e38d": {"doc_hash": "a235c0bd3b4375e34c6d700ac37ac83743822eee9ba34b210dd4acaa9f2c01c9", "ref_doc_id": "low_autocorrel_beginner"}, "e86bdcb5-3d66-42f7-8328-ef51f745fe2a": {"doc_hash": "b61e8c215a811c4b4f8f7a79043a1a698842aa701d3175314dba21bcc51cb532", "ref_doc_id": "magic_hexagon_beginner"}, "23215cd2-03dd-42d1-9f15-3d377869c47a": {"doc_hash": "f6404c3249fbcb43b15ca46777f429e29941dd419e1efdd37cf789f4d16fb81d", "ref_doc_id": "ppp_beginner"}, "cdfa9d00-f8a6-47ce-813b-4703cc55498b": {"doc_hash": "d6c755db8119fe5694cfd96a2865869431bb4993666f5acc6a7aadfbb81739f5", "ref_doc_id": "rag_config_beginner"}, "1b6f807e-5c61-4c7f-ac00-d8afd84bcd54": {"doc_hash": "ea711de294a33f2139a4eab5f2661208257fff6e7455a389d0f87248d1eb2082", "ref_doc_id": "ramsey_beginner"}, "e36a4ccb-5f7f-42f2-adfa-894d4ff10577": {"doc_hash": "19e82e6f4880f6b5c41e8440560beae90dda5fb7398aa20285037cc6702f7a8a", "ref_doc_id": "vellino_beginner"}, "7f98dba6-bc04-4139-98fc-6b234e319741": {"doc_hash": "37381bd81adebc0e44ea8846ffe06df3436eaaca9d177c5cdd0fcaa6a30be29b", "ref_doc_id": "wagner_beginner"}, "115fda5e-c2e5-465e-a3ee-cd1c2977e613": {"doc_hash": "3f91c3ead95f5cc3ad0d39d7b07436e0b763cf8b9e1a34b2a8712fecdb331e13", "ref_doc_id": "word_design_beginner"}}, "docstore/data": {"7fde722a-0268-4c34-b9f6-2d365b45b20c": {"__data__": {"id_": "7fde722a-0268-4c34-b9f6-2d365b45b20c", "embedding": null, "metadata": {"model_name": "knapsack"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "knapsack_beginner", "node_type": "4", "metadata": {"model_name": "knapsack"}, "hash": "1599698582e5ec224f81f8b2586650f8a97784dff7b6caec4e1a46e022f03422", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language Essence 1.3\n$ prob133.essence: Knapsack Problem\n \ngiven items new type enum\ngiven weight, gain : function (total) items --> int\ngiven capacity : int\nfind picked : set of items\nmaximising sum i in picked . gain(i)\nsuch that (sum i in picked . weight(i)) <= capacity\n            ======\n            Description:\n            ---------\n            Knapsack Problem\n\nImagine you're going on a trip and you have a bag with a limited capacity. You have many items you want to bring, each with a weight and a value or gain. The problem is about deciding which items to pick to bring with you to maximize the total value while not exceeding the bag's capacity.\n\nThe main variables are:\n\n* Items: the things you want to bring on the trip (e.g., clothes, books, etc.)\n* Picked: the set of items you choose to bring\n* Weight: how heavy each item is\n* Gain: how valuable each item is\n* Capacity: the maximum weight the bag can hold\n\nThe basic restrictions or rules are:\n\n* You can't bring more items than the bag can hold (i.e., the total weight of the picked items must be less than or equal to the capacity).\n\nThe goal is to maximize the total value of the items you bring (i.e., the sum of the gains of the picked items).", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1263, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "41221a24-d0a6-46be-966d-86d07aa6ff19": {"__data__": {"id_": "41221a24-d0a6-46be-966d-86d07aa6ff19", "embedding": null, "metadata": {"model_name": "lam"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "lam_beginner", "node_type": "4", "metadata": {"model_name": "lam"}, "hash": "e594eaff09d6995842be3528ce385a1ea384ec6d85a20f5e410b2d8efc2e7f97", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language Essence 1.3\n$ prob025.essence: Lam's Problem\n$ Problem details available at http://www.csplib.org/Problems/prob025/\n \ngiven indexSize: int\n \nletting Index be new type of size indexSize\n \nfind m: matrix indexed by [Index,Index] of bool\n \nsuch that\n    forAll r : Index\n        . (sum c : Index . toInt(!m[r,c])) = 11,\n    forAll c : Index\n        . (sum r : Index . toInt(!m[r,c])) = 11,\n    forAll r1,r2 : Index , r1 != r2\n        . (sum c : Index . toInt(!(m[r1,c] \\/ m[r2,c]))) = 1\n\n            ======\n            Description:\n            ---------\n            Lam's Problem\n\nThis problem is about creating a special kind of table with certain rules.\n\nThe main variables are:\n\n* A table (called a matrix) with rows and columns, where each cell can be either true or false.\n* The size of the table, which is given to us.\n\nThe basic restrictions or rules of the problem are:\n\n* Each row of the table must have exactly 11 true cells.\n* Each column of the table must have exactly 11 true cells.\n* For any two different rows, there must be exactly one column where one row has a true cell and the other row has a false cell.\n\nThe goal of the problem is to find a table that satisfies all these rules.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1250, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "efe2dce1-3f8e-474c-ac04-f0b7d775e38d": {"__data__": {"id_": "efe2dce1-3f8e-474c-ac04-f0b7d775e38d", "embedding": null, "metadata": {"model_name": "low_autocorrel"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "low_autocorrel_beginner", "node_type": "4", "metadata": {"model_name": "low_autocorrel"}, "hash": "a235c0bd3b4375e34c6d700ac37ac83743822eee9ba34b210dd4acaa9f2c01c9", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language Essence 1.3\n$ prob005.essence: Low Autocorrellation Binary Sequences\n$ Problem details available at http://www.csplib.org/Problems/prob005/\n \ngiven n : int(1..)\n \nfind seq : function (total) int(1..n) --> int(-1,1)\n \nminimising sum k : int(1..n) . (sum i : int(1..n-k) . seq(i) * seq(i+k)) ** 2\n            ======\n            Description:\n            ---------\n            Low Autocorrelation Binary Sequences\n\nThis problem is about creating a special kind of sequence of numbers that has a certain property. Imagine you have a list of numbers that can be either 1 or -1. The goal is to arrange these numbers in a specific order so that the sequence has low autocorrelation.\n\nThe main variables are:\n\n* n: the length of the sequence (how many numbers are in the list)\n* seq: the sequence of numbers itself (a list of 1s and -1s)\n\nThe basic restrictions or rules of the problem are:\n\n* The sequence can only contain 1s and -1s.\n* The sequence has a fixed length, which is given by the variable n.\n\nThe goal of the problem is to minimize the autocorrelation of the sequence. Autocorrelation measures how similar the sequence is to itself when shifted by a certain number of positions. In this case, we want to find a sequence that has low autocorrelation, meaning it doesn't repeat itself too much when shifted.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1362, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e86bdcb5-3d66-42f7-8328-ef51f745fe2a": {"__data__": {"id_": "e86bdcb5-3d66-42f7-8328-ef51f745fe2a", "embedding": null, "metadata": {"model_name": "magic_hexagon"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "magic_hexagon_beginner", "node_type": "4", "metadata": {"model_name": "magic_hexagon"}, "hash": "b61e8c215a811c4b4f8f7a79043a1a698842aa701d3175314dba21bcc51cb532", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language ESSENCE 1.2.0\n$ prob023.essence: Magic Hexagon\n$ Problem details available at http://www.csplib.org/Problems/prob023/\n$ 03 September 2007\n$\n \n$ d: the diameter of the hexagon (length of the longest row)\ngiven d : int(1..)\n \n$ d must be an odd integer\nwhere d % 2 = 1\n \n$ o: the order of the hexagon (length of the shortest row)\n$ maxval: the maximum value that will appear in the hexagon\n$ maxsum: the maximum value that a row could sum to\n$ Value: the domain consisting of the integers contained in the hexagon\nletting o be d/2 + 1,\n        maxval be 3 * o**2 - 3 * o + 1,\n        maxsum be sum i : int(maxval + 1 - d..maxval) . i,\n        Value be domain int(1..maxval)\n \n$ hexagon: the hexagon is represented by a matrix. for any row i, we are only\n$          interested in the first d - |d/2 + 1 - i| elements of the row\n$ s: the magic number that all rows and diagonals sum to\nfind hexagon : matrix indexed by [int(1..d),int(1..d)] of Value,\n     s : int(1..maxsum)\n \nsuch that\n$ all elements are different (and therefore all values are included)\n    forAll r1,r2 : int(1..d) . forAll i1 : int(1..d - |o - r1|) .\n        forAll i2 : int(1..d - |o - r2|) . r1 != r2 \\/ i1 != i2 ->\n            hexagon[r1,i1] != hexagon[r2,i2],\n$ all rows sum to s\n    forAll r : int(1..d) . (sum i : int(1..d - |o - r|) . hexagon[r,i]) = s,\n$ all right-sloping diagonals sum to s\n    forAll r : int(1..d) . (sum i : int(1..d - |o - r|) .\n        hexagon[i + max({0,o-r}), r - max({0,o-(i + max({0,o-r}))})]) = s,\n$ all left-sloping diagonals sum to s\n    forAll r : int(1..d) . (sum i : int(1..d - |o - r|) .\n        hexagon[i + max({0,r-o}), r - max({0,(i + max({0,r-o}))-o})]) = s\n            ======\n            Description:\n            ---------\n            Magic Hexagon\n\nThis problem is about creating a special kind of hexagon (a six-sided shape) where each cell in the hexagon contains a number. The goal is to arrange these numbers in a way that makes the sums of each row, column, and diagonal equal to a certain \"magic number\".\n\nThe main variables are:\n\n* d: the diameter of the hexagon (how long the longest row is)\n* o: the order of the hexagon (how long the shortest row is)\n* hexagon: a matrix of numbers that represents the hexagon\n* s: the magic number that all rows and diagonals sum to\n\nThe basic restrictions or rules of the problem are:\n\n* Each number in the hexagon must be unique (no duplicates)\n* Each row, column, and diagonal must add up to the magic number s\n* The diameter d must be an odd number\n\nThe goal of the problem is to find a way to arrange the numbers in the hexagon so that all the rows, columns, and diagonals sum up to the magic number s.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2718, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "23215cd2-03dd-42d1-9f15-3d377869c47a": {"__data__": {"id_": "23215cd2-03dd-42d1-9f15-3d377869c47a", "embedding": null, "metadata": {"model_name": "ppp"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ppp_beginner", "node_type": "4", "metadata": {"model_name": "ppp"}, "hash": "f6404c3249fbcb43b15ca46777f429e29941dd419e1efdd37cf789f4d16fb81d", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language Essence 1.3\n$ prob013.essence: Progressive Party Problem\n$ Problem details available at http://www.csplib.org/Problems/prob013/\n \ngiven n_boats, n_periods : int(1..)\n \nletting Boat be domain int(1..n_boats)\n \ngiven capacity, crew : function (total) Boat --> int(1..)\n \nfind hosts : set (minSize 1) of Boat,\n     sched : set (size n_periods) of partition from Boat\n \nminimising |hosts|\n \n$ Hosts remain the same throughout the schedule\nsuch that\n    forAll p in sched . |parts(p)| = |hosts| /\\\n    forAll part in parts(p) . |part intersect hosts| = 1\n \n$ Hosts have the capacity to support the visiting crews\nsuch that forAll p in sched . forAll h in hosts .\n    (sum b in party(h,p) . crew(b)) <= capacity(h)\n \nsuch that allDiff([ (i, j)\n                  | p <- sched\n                  , part <- p\n                  , {i,j} <- powerSet(part)\n                  ])\n            ======\n            Description:\n            ---------\n            Progressive Party Problem\n\nThis problem is about organizing a party where guests arrive and depart at different times, and they need to be hosted by different boats. The goal is to minimize the number of boats needed to host all the guests.\n\nThe main variables are:\n\n* Boats: These are the vessels that will host the guests.\n* Hosts: These are the boats that will be used to host the guests throughout the party.\n* Sched: This is the schedule of which boats will host which guests at each time period.\n* Capacity: This is the maximum number of guests that each boat can hold.\n* Crew: This is the number of guests that arrive at each time period.\n\nThe basic restrictions or rules of the problem are:\n\n* Each boat can only host a certain number of guests at a time.\n* Each guest needs to be hosted by a boat at each time period.\n* The same boats are used throughout the party.\n\nThe goal of the problem is to minimize the number of boats needed to host all the guests.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1960, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cdfa9d00-f8a6-47ce-813b-4703cc55498b": {"__data__": {"id_": "cdfa9d00-f8a6-47ce-813b-4703cc55498b", "embedding": null, "metadata": {"model_name": "rag_config"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "rag_config_beginner", "node_type": "4", "metadata": {"model_name": "rag_config"}, "hash": "d6c755db8119fe5694cfd96a2865869431bb4993666f5acc6a7aadfbb81739f5", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language Essence 1.3\n$ prob031.essence: Rack Configuration Problem\n$ Problem details available at http://www.csplib.org/Problems/prob031/\n \n$ We are using the problem description from the following paper very closely here.\n$ \"Symmetry Breaking in a Rack Configuration Problem\" Zeynep K\u0131z\u0131ltan and Brahim Hnich\n \n \n \n$ The rack configuration problem consists of plugging a set of electronic cards\n$ into racks with electronic connectors.\ngiven nbRacks : int(1..)\nletting Rack be new type of size nbRacks\n \n$ Each card belongs to a certain card type.\ngiven nbTypes : int(1..)\nletting Type be domain int(1..nbTypes)\n \n$ A card type is characterised by the power it requires, ...\ngiven requiredPower : function (total) Type --> int(1..)\n \n$ ... and a demand, which designates how many cards of that type have to be plugged.\ngiven demand : function (total) Type --> int(1..)\n \n \n$ In order to plug a card into a rack, the rack needs to use a rack model.\ngiven nbModels : int\nletting Model be domain int(1..nbModels)\n \n$ Each rack model is characterised by the maximal power it can supply, its number of connectors, and its price.\ngiven maxPower      : function (total) Model --> int(1..)\ngiven maxConnectors : function (total) Model --> int(1..)\ngiven price         : function (total) Model --> int(1..)\n \n$ A rack model can be used by any rack.\n$ Each card plugged into a rack uses a connector.\n$ The problem is to decide how many of the available racks are needed,\n$ and which rack models the racks use in order to plug all the cards\n$ such that the total price is minimised.\n \nfind configuration :\n        function Rack -->\n            $ the model for this rack\n            ( Model\n            $ for each type, the number of cards of that type\n            , function (total) Type --> int(0..max(range(maxConnectors)))\n            )\n \n \n$ The constraints of the problem and the cost function can be summarised as the following:\n \n$ The connector-capacity constraint:\n$ the number of cards plugged into a rack r\n$ must not exceed the number of connectors of the rack model used by r.\nsuch that\n    forAll (rack, (model, counts)) in configuration .\n        sum([ num | (ty, num) <- counts ]) <= maxConnectors(model)\n \n$ The power-capacity constraint:\n$ the total power of the cards plugged into a rack r\n$ must not exceed the power of the rack model used by r.\nsuch that\n    forAll (rack, (model, counts)) in configuration .\n        sum([ requiredPower(ty) * num | (ty, num) <- counts ]) <= maxPower(model)\n \n$ The demand constraint: all the cards have to be plugged into some rack.\nsuch that\n    forAll (ty, tyDemand) in demand .\n        tyDemand <= sum([ num\n                        | (rack, (model, counts)) <- configuration\n                        , (ty2, num) <- counts\n                        , ty = ty2\n                        ])\n \n$ The cost function is the sum of the prices of the rack models used by all the racks needed.\nfind totalCost : int(0.. |Rack| * |Model| * max(range(price)) )\nsuch that totalCost = sum (rack, (model, counts)) in configuration . price(model)\nminimising totalCost\n            ======\n            Description:\n            ---------\n            Rack Configuration Problem\n\nThis problem is about plugging electronic cards into racks with connectors. Imagine you have many cards of different types, and each type needs a certain amount of power to work. You also have different types of racks with different numbers of connectors and power supplies. The goal is to find the best way to plug all the cards into the racks so that they all work and the total cost of the racks is as low as possible.\n\nThe main variables are:\n\n* Racks: These are the containers that hold the electronic cards.\n* Card types: These are the different kinds of electronic cards.\n* Rack models: These are the different types of racks with different power supplies and numbers of connectors.\n* Configuration: This is the plan for which cards go into which racks and which rack models to use.\n\nThe basic restrictions or rules of the problem are:\n\n* Each rack can only hold a certain number of cards, based on the number of connectors it has.\n* Each rack can only supply a certain amount of power, based on the rack model used.\n* All the cards of each type must be plugged into some rack.\n* The total cost of the racks used must be minimized.\n\nThe goal of the problem is to find the configuration that minimizes the total cost of the racks while meeting all the restrictions.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4516, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1b6f807e-5c61-4c7f-ac00-d8afd84bcd54": {"__data__": {"id_": "1b6f807e-5c61-4c7f-ac00-d8afd84bcd54", "embedding": null, "metadata": {"model_name": "ramsey"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ramsey_beginner", "node_type": "4", "metadata": {"model_name": "ramsey"}, "hash": "ea711de294a33f2139a4eab5f2661208257fff6e7455a389d0f87248d1eb2082", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language Essence 1.3\n \n$ The Ramsey number R(k,l) is the smallest number such that\n$ if we two-colour the edges of complete graph of this size,\n$ there always exists a monochromatic subgraph of either k or l nodes.\n \n$ In other words (from Wikipedia):\n$ The Ramsey number, R(k,l), gives the solution to the party problem,\n$ which asks the minimum number of guests, R(k,l), that must be invited\n$ so that at least k will know each other\n$      or at least l will not know each other.\n \n$ Here, we are modelling the Ramsey-graph problem which is the problem of finding counter-examples.\n$ For a given k,l, and num_vertices: find a colouring of the complete graph\n$ which does not have a blue-subgraph nor a red-subgraph.\n \ngiven k, l, num_vertices : int\n \n$ due to symmetry R(k, l) = R(l,k)\nwhere k <= l\n \n$ complete graph, to we can calculate the number of edges\nletting num_edges be num_vertices * (num_vertices - 1)\n \n$ we are two-colouring\nletting Colour be new type enum {red, blue}\n \nletting Vertex be domain int(1..num_vertices)\n \nfind graph : function (size num_edges) (Vertex, Vertex) --> Colour\n \n \n$ the graph is complete\nsuch that\n    forAll i,j : Vertex . i < j ->\n        (i,j) in defined(graph) /\\ graph((i,j)) = graph((j,i)),\n    forAll i : Vertex .\n        !((i,i) in defined(graph))\n \n \n$ there isn't a red-subgraph of size k\nsuch that\n    forAll subgraph_vertices : set (size k) of Vertex .\n        !(forAll {i,j} subsetEq subgraph_vertices . graph((i,j)) = red)\n \n \n$ there isn't a blue-subgraph of size l\nsuch that\n    forAll subgraph_vertices : set (size l) of Vertex .\n        !(forAll {i,j} subsetEq subgraph_vertices . graph((i,j)) = blue)\n            ======\n            Description:\n            ---------\n            **The Ramsey Graph Problem**\n\n**What is the problem about?**\nImagine you're hosting a party and you want to invite a certain number of guests. You want to make sure that either a certain number of guests know each other, or a certain number of guests don't know each other. The problem is to find the smallest number of guests you need to invite to guarantee this.\n\n**Main variables:**\n\n* `k` and `l`: These are the numbers of guests that need to know each other or not know each other, respectively.\n* `num_vertices`: This is the total number of guests at the party.\n* `graph`: This represents the connections between guests, where each connection is either \"red\" (they know each other) or \"blue\" (they don't know each other).\n\n**Basic restrictions or rules:**\n\n* Every guest is connected to every other guest (it's a \"complete graph\").\n* If two guests are connected, the connection is either red or blue.\n* The connections are symmetric, meaning if guest A is connected to guest B, then guest B is also connected to guest A.\n\n**Goal:**\nThe goal is to find a way to color the connections between guests (red or blue) so that there is no group of `k` guests who all know each other (a \"red subgraph\") and no group of `l` guests who all don't know each other (a \"blue subgraph\").", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3063, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e36a4ccb-5f7f-42f2-adfa-894d4ff10577": {"__data__": {"id_": "e36a4ccb-5f7f-42f2-adfa-894d4ff10577", "embedding": null, "metadata": {"model_name": "vellino"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "vellino_beginner", "node_type": "4", "metadata": {"model_name": "vellino"}, "hash": "19e82e6f4880f6b5c41e8440560beae90dda5fb7398aa20285037cc6702f7a8a", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language ESSENCE 1.2.0\n$ prob116.essence: Vellino's Problem\n$ Problem details available in:\n$   The OPL Optimization Programming Language\n$   Pascal Van Hentenryck\n$   MIT Press, January 1999.\n$\n$ 27 July 2007\n$\n \ngiven maxMaterial : int\n \n$ Material: there are five different types of materials\n$ Colour: there are three different types of bin, distinguished by colour\nletting Material be new type enum {glass,plastic,steel,wood,copper},\n        Colour be new type enum {red,green,blue}\n \n$ quantity: the amount of each material that is required to be placed in bins\n$ capacity: each bin type (colour) has a certain capacity\ngiven quantity : function (total) Material --> int(0..),\n      capacity : function (total) Colour --> int(0..)\n \n$ Bin: bins are represented by an unnamed type. the number of values is the same\n$      as the total amount of material that is required\nletting Bin be new type of size (sum m : Material . quantity(m))\n \n$ colour: each bin is assigned a colour\n$ contents: the contents of each bin is a multiset of materials\nfind colour : function Bin --> Colour,\n     $ The size of each mset returned by contents is <= some value returned by capacity (given)\n     contents : function Bin --> mset (maxOccur maxMaterial, maxSize max(range(capacity))) of Material\n \n$ minimise the number of bins that have colours & materials assigned to them\nminimising |defined(colour)|\n \nsuch that\n$ every bin that has a colour, must also have a contents, and vice versa\n    forAll b : Bin . b in defined(colour) <-> b in defined(contents),\n$ the correct amount of each material is spread across all the bins\n    forAll m : Material . (sum b in defined(contents) . freq(contents(b),m))\n                          = quantity(m),\n$ the amount of material in each bin does not exceed its capacity\n    forAll b in defined(colour) . |contents(b)| <= capacity(colour(b)),\n$ red bins cannot contain plastic or steel\n    forAll b in defined(colour) . colour(b) = red ->\n                                   !(plastic in contents(b)) /\\\n                                   !(steel in contents(b)),\n$ blue bins cannot contain wood or plastic\n    forAll b in defined(colour) . colour(b) = blue ->\n                                   !(wood in contents(b)) /\\\n                                   !(plastic in contents(b)),\n$ green bins cannot contain steel or glass\n    forAll b in defined(colour) . colour(b) = green ->\n                                   !(steel in contents(b)) /\\\n                                   !(glass in contents(b)),\n$ red bins contain at most one wooden component\n    forAll b in defined(colour) . colour(b) = red ->\n                                   freq(contents(b),wood) <= 1,\n$ green bins contain at most two wooden components\n    forAll b in defined(colour) . colour(b) = green ->\n                                   freq(contents(b),wood) <= 2,\n$ wood requires plastic\n    forAll b in defined(colour) . wood in contents(b) ->\n                                   plastic in contents(b),\n$ glass excludes copper\n    forAll b in defined(colour) . glass in contents(b) ->\n                                   !(copper in contents(b)),\n$ copper excludes plastic\n    forAll b in defined(colour) . copper in contents(b) ->\n                                   !(plastic in contents(b))\n            ======\n            Description:\n            ---------\n            Vellino's Problem\n\nThis problem is about packing different materials into bins of different colors. Imagine you have five types of materials (glass, plastic, steel, wood, and copper) and three types of bins (red, green, and blue). Each bin can hold a certain amount of material, and you need to put the right amount of each material into the bins.\n\nThe main variables are:\n\n* Materials: the five types of materials (glass, plastic, steel, wood, and copper)\n* Bins: the containers where the materials will be placed\n* Colour: the color of each bin (red, green, or blue)\n* Contents: the materials that are placed in each bin\n\nThe basic restrictions or rules of the problem are:\n\n* Each bin can only hold a certain amount of material\n* Certain materials cannot be placed in certain colored bins (e.g., plastic cannot be placed in red bins)\n* Some materials require other materials to be present (e.g., wood requires plastic)\n* Some materials exclude other materials (e.g., glass excludes copper)\n\nThe goal of the problem is to minimize the number of bins that are used to pack all the materials. In other words, we want to use as few bins as possible to pack all the materials while following the rules and restrictions.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4635, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7f98dba6-bc04-4139-98fc-6b234e319741": {"__data__": {"id_": "7f98dba6-bc04-4139-98fc-6b234e319741", "embedding": null, "metadata": {"model_name": "wagner"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "wagner_beginner", "node_type": "4", "metadata": {"model_name": "wagner"}, "hash": "37381bd81adebc0e44ea8846ffe06df3436eaaca9d177c5cdd0fcaa6a30be29b", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language Essence 1.3\n \n$ ** Updates **\n$ 2021/08/04 - The new model 'DistributionWagnerWhitin-partialfunc.essence' performances\n$              signficantly better in practice.\n \n$ Problem Wagner-Whitin Distribution\n$\n$ Problem details available at http://www.csplib.org/Problems/prob040/\n$\n$ Essence model by Andrew Martin\n$\n$ Licenced under CC-BY-4.0 : http://creativecommons.org/licenses/by/4.0/\n \n$ in this model, rather than define multiple levels, children of each node are defined explicitly\n \ngiven numNodes : int(1..)\n \n$ leaves are always first numLeaves nodes\n$ leaves cannot have any children\ngiven numLeaves : int(1..)\n \n$ period 0 is empty, all stock is 0\ngiven numPeriods : int(1..)\n \n$ used to provide bound to output\ngiven maxStock : int(1..)\n \nletting dNodes be domain int(1..numNodes)\nletting dLeaves be domain int(1..numLeaves)\nletting dAllPeriods be domain int(0..numPeriods)\nletting dPeriods be domain int(1..numPeriods)\n \ngiven holdingCost : matrix indexed by [dNodes] of int(0..)\n \ngiven procCost : matrix indexed by [dNodes] of int(0..)\n \ngiven demand : matrix indexed by [dLeaves, dPeriods] of int(0..)\n \n$ used to determine where supply comes goes to\ngiven children : matrix indexed by [dNodes] of set of dNodes\n \nfind orders : matrix indexed by [dNodes, dPeriods] of int(0..maxStock)\n \n$ AUX find statement\nfind stock : matrix indexed by [dNodes, dAllPeriods] of int(0..maxStock)\n \n$ minimising the cost\n$ holding*stock per period per node plus proc if any orders were placed per period per node\nminimising (sum t : dPeriods . (sum i : dNodes . (holdingCost[i] * stock[i][t] + procCost[i] * toInt(orders[i][t] > 0))))\n \n \nsuch that\n \n$ stock starts at 0\n    forAll i : dNodes .\n        stock[i][0] = 0\n,\n$ non-leaf constraints - orders coming from children must be fulfilled\n    forAll t : dPeriods .\n        forAll i : int(numLeaves+1..numNodes) .\n            stock[i][t] = stock[i][t-1] + orders[i][t] - (sum m in children[i] . orders[m][t])\n,\n$ leaf constraints - demands must be fullfilled\n    forAll t : dPeriods .\n        forAll i : dLeaves .\n            stock[i][t] = stock[i][t-1] + orders[i][t] - demand[i][t]\n            ======\n            Description:\n            ---------\n            Wagner-Whitin Distribution Problem\n\nThis problem is about managing inventory and supply chain for a company that produces goods. Imagine a company that makes products and needs to store them in warehouses. The company wants to minimize the cost of storing and producing these products while making sure it has enough stock to meet customer demand.\n\nThe main variables are:\n\n* `orders`: the amount of products to order from each warehouse in each time period\n* `stock`: the amount of products stored in each warehouse in each time period\n\nThe basic restrictions or rules of the problem are:\n\n* The company starts with no stock in any warehouse\n* The company must fulfill customer demand for each product in each time period\n* The company can only supply products to its customers from its warehouses\n* The company wants to minimize the cost of storing and producing products\n\nThe goal of the problem is to minimize the total cost of storing and producing products while meeting customer demand. The cost includes the cost of holding products in stock and the cost of producing new products to meet demand.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3372, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "115fda5e-c2e5-465e-a3ee-cd1c2977e613": {"__data__": {"id_": "115fda5e-c2e5-465e-a3ee-cd1c2977e613", "embedding": null, "metadata": {"model_name": "word_design"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "word_design_beginner", "node_type": "4", "metadata": {"model_name": "word_design"}, "hash": "3f91c3ead95f5cc3ad0d39d7b07436e0b763cf8b9e1a34b2a8712fecdb331e13", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language Essence 1.3\n$ prob033.essence: Word Design for DNA Computing on Surfaces\n$ Problem details available at http://www.csplib.org/Problems/prob033/\n \nletting Base be new type enum {A,C,G,T},\n        Index be domain int(1..8)\n \n$ Notice: The problem specification states that we are trying to find a set of words.\n$ We take this literally, and do not allow repeated words.\n \nfind words : set of function (total) Index --> Base\n \nmaximising |words|\n \nsuch that\n \n    $ Each word in S has 4 symbols from (C, G)\n    forAll w in words . |preImage(w,C)| + |preImage(w,G)| = 4,\n \n    $ Each pair of words in S differ in at least 4 positions\n    forAll {w1,w2} subsetEq words .\n        (sum i : Index . toInt(w1(i) != w2(i))) >= 4,\n \n    forAll {w1,w2} subsetEq words .\n        (sum i : Index .\n            $\n            $ To decide whether they are identical at index i, we need to inspect the values of w1(9-i) and w2(i).\n            $ This is because w1 is reversed, and w2 is the Watson-Crick complement.\n            $\n            $ Watson-Crick complementing is implemented by listing a set of allowed pairs.\n            $ If the pair is a member of the set of allowed pairs, they are identical.\n            $\n            $ We require that they are not identical (hence the negation) in at least 4 positions.\n            $\n            toInt(! ((w1(9-i), w2(i)) in {(A,T), (C,G), (G,C), (T,A)}) )\n        ) >= 4\n            ======\n            Description:\n            ---------\n            DNA Word Design Problem\n\nThis problem is about designing a set of special words that can be used in DNA computing on surfaces. Imagine you have a set of Lego blocks with four different shapes (A, C, G, and T) and you want to build a collection of short words using these blocks.\n\nThe main variables are the words, which are like short sequences of these Lego blocks. Each word has 8 blocks, and each block can be one of the four shapes.\n\nThe basic restrictions or rules of the problem are:\n\n* Each word must have exactly 4 blocks that are either C or G.\n* Any two words in the collection must be different in at least 4 positions.\n* When you reverse one word and compare it to another word, they must be different in at least 4 positions, following some specific rules about which blocks can be paired together (like A can be paired with T, and C can be paired with G).\n\nThe goal of the problem is to find the largest possible collection of words that follow these rules.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2506, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"knapsack_beginner": {"node_ids": ["7fde722a-0268-4c34-b9f6-2d365b45b20c"], "metadata": {"model_name": "knapsack"}}, "lam_beginner": {"node_ids": ["41221a24-d0a6-46be-966d-86d07aa6ff19"], "metadata": {"model_name": "lam"}}, "low_autocorrel_beginner": {"node_ids": ["efe2dce1-3f8e-474c-ac04-f0b7d775e38d"], "metadata": {"model_name": "low_autocorrel"}}, "magic_hexagon_beginner": {"node_ids": ["e86bdcb5-3d66-42f7-8328-ef51f745fe2a"], "metadata": {"model_name": "magic_hexagon"}}, "ppp_beginner": {"node_ids": ["23215cd2-03dd-42d1-9f15-3d377869c47a"], "metadata": {"model_name": "ppp"}}, "rag_config_beginner": {"node_ids": ["cdfa9d00-f8a6-47ce-813b-4703cc55498b"], "metadata": {"model_name": "rag_config"}}, "ramsey_beginner": {"node_ids": ["1b6f807e-5c61-4c7f-ac00-d8afd84bcd54"], "metadata": {"model_name": "ramsey"}}, "vellino_beginner": {"node_ids": ["e36a4ccb-5f7f-42f2-adfa-894d4ff10577"], "metadata": {"model_name": "vellino"}}, "wagner_beginner": {"node_ids": ["7f98dba6-bc04-4139-98fc-6b234e319741"], "metadata": {"model_name": "wagner"}}, "word_design_beginner": {"node_ids": ["115fda5e-c2e5-465e-a3ee-cd1c2977e613"], "metadata": {"model_name": "word_design"}}}}