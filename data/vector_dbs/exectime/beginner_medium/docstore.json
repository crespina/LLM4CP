{"docstore/metadata": {"knapsack_beginner_medium": {"doc_hash": "9608738b98f2830b45a36a057d702c833df60d02171a2cedb07fa55f35a6ebfd"}, "lam_beginner_medium": {"doc_hash": "4a7aab56c95817164499d256dc7a57bf9ba263a51168141ee0fe4324e6c97794"}, "low_autocorrel_beginner_medium": {"doc_hash": "4a5302d0584f30a82d60fa33d76ea7d98b4910f0d95bf209a4fb247541da3676"}, "magic_hexagon_beginner_medium": {"doc_hash": "99e34c8941a0bede2d7db349e78afde36fcb2cba275bcd0c172b3d858ffbe717"}, "ppp_beginner_medium": {"doc_hash": "7dea0eb4bf2f8c1d40383d689249419e7e5fce3bac4464e4afecd263a755c931"}, "rag_config_beginner_medium": {"doc_hash": "8a77406f7aa236d79d7c137469eea92110dc14f2ff71d0cb24ad511c7bedcf45"}, "ramsey_beginner_medium": {"doc_hash": "1958a1a0ba4ce3be28a9513cbf456ed32732592c08590e9639de4a9396e68982"}, "vellino_beginner_medium": {"doc_hash": "063585a234daca112735b81277129f02ee29521a791e2ed6ff8b992d5fad5870"}, "wagner_beginner_medium": {"doc_hash": "a3e150929e04713a8266d4d55216660bc6e666f55d39f34473767be7c988d276"}, "word_design_beginner_medium": {"doc_hash": "5b4d3220ee431e586d82293e092f01fc3f9b7716a6faf39ef537398fb4dc93dc"}, "66a5facf-6b54-4379-bd2e-341bb52a92b4": {"doc_hash": "9608738b98f2830b45a36a057d702c833df60d02171a2cedb07fa55f35a6ebfd", "ref_doc_id": "knapsack_beginner_medium"}, "058184eb-c0a1-4e9b-abdf-f53828706b68": {"doc_hash": "4a7aab56c95817164499d256dc7a57bf9ba263a51168141ee0fe4324e6c97794", "ref_doc_id": "lam_beginner_medium"}, "16985e54-11d1-46cf-93e3-edefc0507d58": {"doc_hash": "4a5302d0584f30a82d60fa33d76ea7d98b4910f0d95bf209a4fb247541da3676", "ref_doc_id": "low_autocorrel_beginner_medium"}, "36f2173b-5381-4279-bf29-f699147788da": {"doc_hash": "99e34c8941a0bede2d7db349e78afde36fcb2cba275bcd0c172b3d858ffbe717", "ref_doc_id": "magic_hexagon_beginner_medium"}, "064f6800-0abc-4b6e-ba17-c91392040301": {"doc_hash": "7dea0eb4bf2f8c1d40383d689249419e7e5fce3bac4464e4afecd263a755c931", "ref_doc_id": "ppp_beginner_medium"}, "ddb65ea4-e15f-47b7-b7e7-2f5b4b59169f": {"doc_hash": "8a77406f7aa236d79d7c137469eea92110dc14f2ff71d0cb24ad511c7bedcf45", "ref_doc_id": "rag_config_beginner_medium"}, "493d1fee-70fc-4d6a-b845-e7d0ffebb2f8": {"doc_hash": "1958a1a0ba4ce3be28a9513cbf456ed32732592c08590e9639de4a9396e68982", "ref_doc_id": "ramsey_beginner_medium"}, "84a6cada-d0bd-41ac-98a1-cc34d7d938d8": {"doc_hash": "063585a234daca112735b81277129f02ee29521a791e2ed6ff8b992d5fad5870", "ref_doc_id": "vellino_beginner_medium"}, "94fbf166-ce6e-4a3f-8851-c7b901d27a20": {"doc_hash": "a3e150929e04713a8266d4d55216660bc6e666f55d39f34473767be7c988d276", "ref_doc_id": "wagner_beginner_medium"}, "221c9722-87c0-4ca0-98c9-d9b6965c5e78": {"doc_hash": "5b4d3220ee431e586d82293e092f01fc3f9b7716a6faf39ef537398fb4dc93dc", "ref_doc_id": "word_design_beginner_medium"}}, "docstore/data": {"66a5facf-6b54-4379-bd2e-341bb52a92b4": {"__data__": {"id_": "66a5facf-6b54-4379-bd2e-341bb52a92b4", "embedding": null, "metadata": {"model_name": "knapsack"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "knapsack_beginner_medium", "node_type": "4", "metadata": {"model_name": "knapsack"}, "hash": "9608738b98f2830b45a36a057d702c833df60d02171a2cedb07fa55f35a6ebfd", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n------\nlanguage Essence 1.3\n$ prob133.essence: Knapsack Problem\n \ngiven items new type enum\ngiven weight, gain : function (total) items --> int\ngiven capacity : int\nfind picked : set of items\nmaximising sum i in picked . gain(i)\nsuch that (sum i in picked . weight(i)) <= capacity\n======\nDescription 1:\n------\nKnapsack Problem\n\nImagine you're going on a trip and you have a bag with a limited capacity. You have many items you want to bring, each with a weight and a value or gain. The problem is about deciding which items to pick to bring with you to maximize the total value while not exceeding the bag's capacity.\n\nThe main variables are:\n\n* Items: the things you want to bring on the trip (e.g., clothes, books, etc.)\n* Picked: the set of items you choose to bring\n* Weight: how heavy each item is\n* Gain: how valuable each item is\n* Capacity: the maximum weight the bag can hold\n\nThe basic restrictions or rules are:\n\n* You can't bring more items than the bag can hold (i.e., the total weight of the picked items must be less than or equal to the capacity).\n\nThe goal is to maximize the total value of the items you bring (i.e., the sum of the gains of the picked items).\n======\nDescription 2:\n------\nThe 0/1 Knapsack Problem.\n\nThis problem is about selecting a subset of items to include in a knapsack of limited capacity, with the goal of maximizing the total value of the selected items while not exceeding the knapsack's weight capacity.\n\nThe main decision variables are the elements of the set `picked`, which represent the items that are selected to be included in the knapsack.\n\nThe key constraints are:\n\n* The total weight of the selected items must not exceed the knapsack's capacity.\n* Each item is either selected (included in the knapsack) or not selected.\n\nThe objective is to maximize the total gain (or value) of the selected items.\n\nIn essence, the problem is about making a selection of items that provides the highest value while staying within the weight constraints of the knapsack.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2021, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "058184eb-c0a1-4e9b-abdf-f53828706b68": {"__data__": {"id_": "058184eb-c0a1-4e9b-abdf-f53828706b68", "embedding": null, "metadata": {"model_name": "lam"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "lam_beginner_medium", "node_type": "4", "metadata": {"model_name": "lam"}, "hash": "4a7aab56c95817164499d256dc7a57bf9ba263a51168141ee0fe4324e6c97794", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n------\nlanguage Essence 1.3\n$ prob025.essence: Lam's Problem\n$ Problem details available at http://www.csplib.org/Problems/prob025/\n \ngiven indexSize: int\n \nletting Index be new type of size indexSize\n \nfind m: matrix indexed by [Index,Index] of bool\n \nsuch that\n    forAll r : Index\n        . (sum c : Index . toInt(!m[r,c])) = 11,\n    forAll c : Index\n        . (sum r : Index . toInt(!m[r,c])) = 11,\n    forAll r1,r2 : Index , r1 != r2\n        . (sum c : Index . toInt(!(m[r1,c] \\/ m[r2,c]))) = 1\n\n======\nDescription 1:\n------\nLam's Problem\n\nThis problem is about creating a special kind of table with certain rules.\n\nThe main variables are:\n\n* A table (called a matrix) with rows and columns, where each cell can be either true or false.\n* The size of the table, which is given to us.\n\nThe basic restrictions or rules of the problem are:\n\n* Each row of the table must have exactly 11 true cells.\n* Each column of the table must have exactly 11 true cells.\n* For any two different rows, there must be exactly one column where one row has a true cell and the other row has a false cell.\n\nThe goal of the problem is to find a table that satisfies all these rules.\n======\nDescription 2:\n------\nLam's Problem.\n\nLam's Problem is a classic constraint programming problem that involves finding a matrix of boolean values that satisfies certain constraints. The problem is about constructing a matrix with specific properties, which makes it a challenging and interesting problem in the field of constraint programming.\n\nThe main decision variables in this problem are the elements of the matrix `m`, which is a matrix indexed by `Index` and `Index`, where `Index` is a type of size `indexSize`. Each element `m[r,c]` represents a boolean value that indicates whether a certain condition is true or false.\n\nThe key constraints in this problem can be described as follows:\n\n* Each row of the matrix must sum up to 11, meaning that exactly 11 elements in each row must be true.\n* Each column of the matrix must sum up to 11, meaning that exactly 11 elements in each column must be true.\n* For any two distinct rows `r1` and `r2`, there must be exactly one column `c` such that either `m[r1,c]` or `m[r2,c]` is true, but not both.\n\nThe objective of this problem is to find a matrix that satisfies all these constraints. There is no explicit objective function to minimize or maximize, as the goal is to find a feasible solution that meets all the constraints.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2464, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "16985e54-11d1-46cf-93e3-edefc0507d58": {"__data__": {"id_": "16985e54-11d1-46cf-93e3-edefc0507d58", "embedding": null, "metadata": {"model_name": "low_autocorrel"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "low_autocorrel_beginner_medium", "node_type": "4", "metadata": {"model_name": "low_autocorrel"}, "hash": "4a5302d0584f30a82d60fa33d76ea7d98b4910f0d95bf209a4fb247541da3676", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n------\nlanguage Essence 1.3\n$ prob005.essence: Low Autocorrellation Binary Sequences\n$ Problem details available at http://www.csplib.org/Problems/prob005/\n \ngiven n : int(1..)\n \nfind seq : function (total) int(1..n) --> int(-1,1)\n \nminimising sum k : int(1..n) . (sum i : int(1..n-k) . seq(i) * seq(i+k)) ** 2\n======\nDescription 1:\n------\nLow Autocorrelation Binary Sequences\n\nThis problem is about creating a special kind of sequence of numbers that has a certain property. Imagine you have a list of numbers that can be either 1 or -1. The goal is to arrange these numbers in a specific order so that the sequence has low autocorrelation.\n\nThe main variables are:\n\n* n: the length of the sequence (how many numbers are in the list)\n* seq: the sequence of numbers itself (a list of 1s and -1s)\n\nThe basic restrictions or rules of the problem are:\n\n* The sequence can only contain 1s and -1s.\n* The sequence has a fixed length, which is given by the variable n.\n\nThe goal of the problem is to minimize the autocorrelation of the sequence. Autocorrelation measures how similar the sequence is to itself when shifted by a certain number of positions. In this case, we want to find a sequence that has low autocorrelation, meaning it doesn't repeat itself too much when shifted.\n======\nDescription 2:\n------\nLow Autocorrelation Binary Sequences Problem.\n\nThis problem is about finding a binary sequence of length `n` with the lowest possible autocorrelation. In other words, we want to find a sequence of `+1` and `-1` values where the correlation between the sequence and its shifted versions is minimized.\n\nThe main decision variable is `seq`, a function that assigns a value of `+1` or `-1` to each position in the sequence.\n\nThe key constraints are:\n\n* The sequence must have a length of `n`.\n* Each element in the sequence must be either `+1` or `-1`.\n\nThe objective is to minimize the sum of the squared autocorrelations of the sequence. Autocorrelation is a measure of how similar a sequence is to its shifted versions. In this problem, we calculate the autocorrelation by multiplying corresponding elements of the sequence and its shifted versions, summing these products, and then squaring the result. The goal is to find a sequence that has the lowest possible sum of these squared autocorrelations.\n\nIn essence, this problem is about finding a binary sequence that is as dissimilar as possible to its own shifted versions, which has applications in various fields such as signal processing, coding theory, and cryptography.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2545, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "36f2173b-5381-4279-bf29-f699147788da": {"__data__": {"id_": "36f2173b-5381-4279-bf29-f699147788da", "embedding": null, "metadata": {"model_name": "magic_hexagon"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "magic_hexagon_beginner_medium", "node_type": "4", "metadata": {"model_name": "magic_hexagon"}, "hash": "99e34c8941a0bede2d7db349e78afde36fcb2cba275bcd0c172b3d858ffbe717", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n------\nlanguage ESSENCE 1.2.0\n$ prob023.essence: Magic Hexagon\n$ Problem details available at http://www.csplib.org/Problems/prob023/\n$ 03 September 2007\n$\n \n$ d: the diameter of the hexagon (length of the longest row)\ngiven d : int(1..)\n \n$ d must be an odd integer\nwhere d % 2 = 1\n \n$ o: the order of the hexagon (length of the shortest row)\n$ maxval: the maximum value that will appear in the hexagon\n$ maxsum: the maximum value that a row could sum to\n$ Value: the domain consisting of the integers contained in the hexagon\nletting o be d/2 + 1,\n        maxval be 3 * o**2 - 3 * o + 1,\n        maxsum be sum i : int(maxval + 1 - d..maxval) . i,\n        Value be domain int(1..maxval)\n \n$ hexagon: the hexagon is represented by a matrix. for any row i, we are only\n$          interested in the first d - |d/2 + 1 - i| elements of the row\n$ s: the magic number that all rows and diagonals sum to\nfind hexagon : matrix indexed by [int(1..d),int(1..d)] of Value,\n     s : int(1..maxsum)\n \nsuch that\n$ all elements are different (and therefore all values are included)\n    forAll r1,r2 : int(1..d) . forAll i1 : int(1..d - |o - r1|) .\n        forAll i2 : int(1..d - |o - r2|) . r1 != r2 \\/ i1 != i2 ->\n            hexagon[r1,i1] != hexagon[r2,i2],\n$ all rows sum to s\n    forAll r : int(1..d) . (sum i : int(1..d - |o - r|) . hexagon[r,i]) = s,\n$ all right-sloping diagonals sum to s\n    forAll r : int(1..d) . (sum i : int(1..d - |o - r|) .\n        hexagon[i + max({0,o-r}), r - max({0,o-(i + max({0,o-r}))})]) = s,\n$ all left-sloping diagonals sum to s\n    forAll r : int(1..d) . (sum i : int(1..d - |o - r|) .\n        hexagon[i + max({0,r-o}), r - max({0,(i + max({0,r-o}))-o})]) = s\n======\nDescription 1:\n------\nMagic Hexagon\n\nThis problem is about creating a special kind of hexagon (a six-sided shape) where each cell in the hexagon contains a number. The goal is to arrange these numbers in a way that makes the sums of each row, column, and diagonal equal to a certain \"magic number\".\n\nThe main variables are:\n\n* d: the diameter of the hexagon (how long the longest row is)\n* o: the order of the hexagon (how long the shortest row is)\n* hexagon: a matrix of numbers that represents the hexagon\n* s: the magic number that all rows and diagonals sum to\n\nThe basic restrictions or rules of the problem are:\n\n* Each number in the hexagon must be unique (no duplicates)\n* Each row, column, and diagonal must add up to the magic number s\n* The diameter d must be an odd number\n\nThe goal of the problem is to find a way to arrange the numbers in the hexagon so that all the rows, columns, and diagonals sum up to the magic number s.\n======\nDescription 2:\n------\nMagic Hexagon Problem.\n\nThe Magic Hexagon problem is a classic constraint programming problem that involves creating a hexagonal arrangement of numbers such that each row, column, and diagonal sums up to a specific magic number.\n\nThe main decision variables in this problem are:\n\n* `hexagon`: a matrix representing the hexagonal arrangement of numbers, where each element is an integer between 1 and `maxval`.\n* `s`: the magic number that all rows and diagonals sum up to.\n\nThe key constraints in this problem are:\n\n* Each element in the hexagon is unique (i.e., all numbers from 1 to `maxval` are used exactly once).\n* Each row in the hexagon sums up to the magic number `s`.\n* Each right-sloping diagonal in the hexagon sums up to the magic number `s`.\n* Each left-sloping diagonal in the hexagon sums up to the magic number `s`.\n\nThe objective of this problem is to find a valid hexagonal arrangement that satisfies all the constraints, without any specific optimization goal (i.e., it's a satisfaction problem rather than an optimization problem).", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3726, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "064f6800-0abc-4b6e-ba17-c91392040301": {"__data__": {"id_": "064f6800-0abc-4b6e-ba17-c91392040301", "embedding": null, "metadata": {"model_name": "ppp"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ppp_beginner_medium", "node_type": "4", "metadata": {"model_name": "ppp"}, "hash": "7dea0eb4bf2f8c1d40383d689249419e7e5fce3bac4464e4afecd263a755c931", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n------\nlanguage Essence 1.3\n$ prob013.essence: Progressive Party Problem\n$ Problem details available at http://www.csplib.org/Problems/prob013/\n \ngiven n_boats, n_periods : int(1..)\n \nletting Boat be domain int(1..n_boats)\n \ngiven capacity, crew : function (total) Boat --> int(1..)\n \nfind hosts : set (minSize 1) of Boat,\n     sched : set (size n_periods) of partition from Boat\n \nminimising |hosts|\n \n$ Hosts remain the same throughout the schedule\nsuch that\n    forAll p in sched . |parts(p)| = |hosts| /\\\n    forAll part in parts(p) . |part intersect hosts| = 1\n \n$ Hosts have the capacity to support the visiting crews\nsuch that forAll p in sched . forAll h in hosts .\n    (sum b in party(h,p) . crew(b)) <= capacity(h)\n \nsuch that allDiff([ (i, j)\n                  | p <- sched\n                  , part <- p\n                  , {i,j} <- powerSet(part)\n                  ])\n======\nDescription 1:\n------\nProgressive Party Problem\n\nThis problem is about organizing a party where guests arrive and depart at different times, and they need to be hosted by different boats. The goal is to minimize the number of boats needed to host all the guests.\n\nThe main variables are:\n\n* Boats: These are the vessels that will host the guests.\n* Hosts: These are the boats that will be used to host the guests throughout the party.\n* Sched: This is the schedule of which boats will host which guests at each time period.\n* Capacity: This is the maximum number of guests that each boat can hold.\n* Crew: This is the number of guests that arrive at each time period.\n\nThe basic restrictions or rules of the problem are:\n\n* Each boat can only host a certain number of guests at a time.\n* Each guest needs to be hosted by a boat at each time period.\n* The same boats are used throughout the party.\n\nThe goal of the problem is to minimize the number of boats needed to host all the guests.\n======\nDescription 2:\n------\nProgressive Party Problem.\n\nThis problem is about organizing a series of parties where a set of boats with different capacities need to host crews of varying sizes over multiple periods. The goal is to minimize the number of boats required to host all the crews while ensuring that each boat has the capacity to support the visiting crews and that each crew is assigned to a unique boat in each period.\n\nThe main decision variables are:\n\n* `hosts`: a set of boats that will be used to host the crews\n* `sched`: a schedule that assigns each boat to a period and divides the boats into partitions (or groups) for each period\n\nThe key constraints are:\n\n* Each period must have the same number of partitions (or groups) as the number of hosts.\n* Each partition in each period must contain exactly one host.\n* The total crew size assigned to each host in each period must not exceed the host's capacity.\n* Each pair of boats must be assigned to different partitions in each period (i.e., no two boats can be in the same partition).\n\nThe objective is to minimize the number of hosts (boats) required to host all the crews.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3033, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ddb65ea4-e15f-47b7-b7e7-2f5b4b59169f": {"__data__": {"id_": "ddb65ea4-e15f-47b7-b7e7-2f5b4b59169f", "embedding": null, "metadata": {"model_name": "rag_config"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "rag_config_beginner_medium", "node_type": "4", "metadata": {"model_name": "rag_config"}, "hash": "8a77406f7aa236d79d7c137469eea92110dc14f2ff71d0cb24ad511c7bedcf45", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n------\nlanguage Essence 1.3\n$ prob031.essence: Rack Configuration Problem\n$ Problem details available at http://www.csplib.org/Problems/prob031/\n \n$ We are using the problem description from the following paper very closely here.\n$ \"Symmetry Breaking in a Rack Configuration Problem\" Zeynep K\u0131z\u0131ltan and Brahim Hnich\n \n \n \n$ The rack configuration problem consists of plugging a set of electronic cards\n$ into racks with electronic connectors.\ngiven nbRacks : int(1..)\nletting Rack be new type of size nbRacks\n \n$ Each card belongs to a certain card type.\ngiven nbTypes : int(1..)\nletting Type be domain int(1..nbTypes)\n \n$ A card type is characterised by the power it requires, ...\ngiven requiredPower : function (total) Type --> int(1..)\n \n$ ... and a demand, which designates how many cards of that type have to be plugged.\ngiven demand : function (total) Type --> int(1..)\n \n \n$ In order to plug a card into a rack, the rack needs to use a rack model.\ngiven nbModels : int\nletting Model be domain int(1..nbModels)\n \n$ Each rack model is characterised by the maximal power it can supply, its number of connectors, and its price.\ngiven maxPower      : function (total) Model --> int(1..)\ngiven maxConnectors : function (total) Model --> int(1..)\ngiven price         : function (total) Model --> int(1..)\n \n$ A rack model can be used by any rack.\n$ Each card plugged into a rack uses a connector.\n$ The problem is to decide how many of the available racks are needed,\n$ and which rack models the racks use in order to plug all the cards\n$ such that the total price is minimised.\n \nfind configuration :\n        function Rack -->\n            $ the model for this rack\n            ( Model\n            $ for each type, the number of cards of that type\n            , function (total) Type --> int(0..max(range(maxConnectors)))\n            )\n \n \n$ The constraints of the problem and the cost function can be summarised as the following:\n \n$ The connector-capacity constraint:\n$ the number of cards plugged into a rack r\n$ must not exceed the number of connectors of the rack model used by r.\nsuch that\n    forAll (rack, (model, counts)) in configuration .\n        sum([ num | (ty, num) <- counts ]) <= maxConnectors(model)\n \n$ The power-capacity constraint:\n$ the total power of the cards plugged into a rack r\n$ must not exceed the power of the rack model used by r.\nsuch that\n    forAll (rack, (model, counts)) in configuration .\n        sum([ requiredPower(ty) * num | (ty, num) <- counts ]) <= maxPower(model)\n \n$ The demand constraint: all the cards have to be plugged into some rack.\nsuch that\n    forAll (ty, tyDemand) in demand .\n        tyDemand <= sum([ num\n                        | (rack, (model, counts)) <- configuration\n                        , (ty2, num) <- counts\n                        , ty = ty2\n                        ])\n \n$ The cost function is the sum of the prices of the rack models used by all the racks needed.\nfind totalCost : int(0.. |Rack| * |Model| * max(range(price)) )\nsuch that totalCost = sum (rack, (model, counts)) in configuration . price(model)\nminimising totalCost\n======\nDescription 1:\n------\nRack Configuration Problem\n\nThis problem is about plugging electronic cards into racks with connectors. Imagine you have many cards of different types, and each type needs a certain amount of power to work. You also have different types of racks with different numbers of connectors and power supplies. The goal is to find the best way to plug all the cards into the racks so that they all work and the total cost of the racks is as low as possible.\n\nThe main variables are:\n\n* Racks: These are the containers that hold the electronic cards.\n* Card types: These are the different kinds of electronic cards.\n* Rack models: These are the different types of racks with different power supplies and numbers of connectors.\n* Configuration: This is the plan for which cards go into which racks and which rack models to use.\n\nThe basic restrictions or rules of the problem are:\n\n* Each rack can only hold a certain number of cards, based on the number of connectors it has.\n* Each rack can only supply a certain amount of power, based on the rack model used.\n* All the cards of each type must be plugged into some rack.\n* The total cost of the racks used must be minimized.\n\nThe goal of the problem is to find the configuration that minimizes the total cost of the racks while meeting all the restrictions.\n======\nDescription 2:\n------\nRack Configuration Problem\n\nThe Rack Configuration Problem is a classic constraint programming problem that involves configuring racks to plug in electronic cards of different types. The goal is to minimize the total cost of the rack models used while satisfying the power and connector capacity constraints.\n\nThe main decision variables in this problem are:\n\n* `configuration`: a function that assigns a rack model and a set of card counts to each rack. The card counts represent the number of cards of each type plugged into the rack.\n\nThe key constraints in this problem are:\n\n* Connector-capacity constraint: The total number of cards plugged into a rack cannot exceed the number of connectors available on the rack model used.\n* Power-capacity constraint: The total power required by the cards plugged into a rack cannot exceed the power capacity of the rack model used.\n* Demand constraint: All cards of each type must be plugged into some rack, satisfying the demand for each card type.\n\nThe objective of the problem is to minimize the total cost of the rack models used, which is calculated by summing the prices of the rack models assigned to each rack.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 5635, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "493d1fee-70fc-4d6a-b845-e7d0ffebb2f8": {"__data__": {"id_": "493d1fee-70fc-4d6a-b845-e7d0ffebb2f8", "embedding": null, "metadata": {"model_name": "ramsey"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ramsey_beginner_medium", "node_type": "4", "metadata": {"model_name": "ramsey"}, "hash": "1958a1a0ba4ce3be28a9513cbf456ed32732592c08590e9639de4a9396e68982", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n------\nlanguage Essence 1.3\n \n$ The Ramsey number R(k,l) is the smallest number such that\n$ if we two-colour the edges of complete graph of this size,\n$ there always exists a monochromatic subgraph of either k or l nodes.\n \n$ In other words (from Wikipedia):\n$ The Ramsey number, R(k,l), gives the solution to the party problem,\n$ which asks the minimum number of guests, R(k,l), that must be invited\n$ so that at least k will know each other\n$      or at least l will not know each other.\n \n$ Here, we are modelling the Ramsey-graph problem which is the problem of finding counter-examples.\n$ For a given k,l, and num_vertices: find a colouring of the complete graph\n$ which does not have a blue-subgraph nor a red-subgraph.\n \ngiven k, l, num_vertices : int\n \n$ due to symmetry R(k, l) = R(l,k)\nwhere k <= l\n \n$ complete graph, to we can calculate the number of edges\nletting num_edges be num_vertices * (num_vertices - 1)\n \n$ we are two-colouring\nletting Colour be new type enum {red, blue}\n \nletting Vertex be domain int(1..num_vertices)\n \nfind graph : function (size num_edges) (Vertex, Vertex) --> Colour\n \n \n$ the graph is complete\nsuch that\n    forAll i,j : Vertex . i < j ->\n        (i,j) in defined(graph) /\\ graph((i,j)) = graph((j,i)),\n    forAll i : Vertex .\n        !((i,i) in defined(graph))\n \n \n$ there isn't a red-subgraph of size k\nsuch that\n    forAll subgraph_vertices : set (size k) of Vertex .\n        !(forAll {i,j} subsetEq subgraph_vertices . graph((i,j)) = red)\n \n \n$ there isn't a blue-subgraph of size l\nsuch that\n    forAll subgraph_vertices : set (size l) of Vertex .\n        !(forAll {i,j} subsetEq subgraph_vertices . graph((i,j)) = blue)\n======\nDescription 1:\n------\n**The Ramsey Graph Problem**\n\n**What is the problem about?**\nImagine you're hosting a party and you want to invite a certain number of guests. You want to make sure that either a certain number of guests know each other, or a certain number of guests don't know each other. The problem is to find the smallest number of guests you need to invite to guarantee this.\n\n**Main variables:**\n\n* `k` and `l`: These are the numbers of guests that need to know each other or not know each other, respectively.\n* `num_vertices`: This is the total number of guests at the party.\n* `graph`: This represents the connections between guests, where each connection is either \"red\" (they know each other) or \"blue\" (they don't know each other).\n\n**Basic restrictions or rules:**\n\n* Every guest is connected to every other guest (it's a \"complete graph\").\n* If two guests are connected, the connection is either red or blue.\n* The connections are symmetric, meaning if guest A is connected to guest B, then guest B is also connected to guest A.\n\n**Goal:**\nThe goal is to find a way to color the connections between guests (red or blue) so that there is no group of `k` guests who all know each other (a \"red subgraph\") and no group of `l` guests who all don't know each other (a \"blue subgraph\").\n======\nDescription 2:\n------\nThe Ramsey Number Problem.\n\nThe Ramsey Number Problem is a classic problem in graph theory and constraint programming. It's about finding the smallest complete graph that, when its edges are colored with two colors (red and blue), does not contain a monochromatic subgraph of a certain size.\n\nThe main decision variables in this problem are the colors assigned to each edge in the complete graph, represented by the `graph` function. This function takes two vertices as input and returns the color of the edge between them (either red or blue).\n\nThe key constraints in this problem are:\n\n* The graph is complete, meaning every pair of vertices is connected by an edge.\n* The graph is symmetric, meaning the color of the edge between vertices i and j is the same as the color of the edge between vertices j and i.\n* There is no subgraph with k vertices where all edges are red (no red-subgraph of size k).\n* There is no subgraph with l vertices where all edges are blue (no blue-subgraph of size l).\n\nThe objective of this problem is to find a coloring of the complete graph that satisfies these constraints, which means finding a counter-example to the Ramsey number problem.\n\nIn simpler terms, imagine you're hosting a party and you want to invite a minimum number of guests such that either at least k guests know each other or at least l guests don't know each other. The Ramsey Number Problem is about finding the smallest number of guests you need to invite to guarantee this.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4501, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "84a6cada-d0bd-41ac-98a1-cc34d7d938d8": {"__data__": {"id_": "84a6cada-d0bd-41ac-98a1-cc34d7d938d8", "embedding": null, "metadata": {"model_name": "vellino"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "vellino_beginner_medium", "node_type": "4", "metadata": {"model_name": "vellino"}, "hash": "063585a234daca112735b81277129f02ee29521a791e2ed6ff8b992d5fad5870", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n------\nlanguage ESSENCE 1.2.0\n$ prob116.essence: Vellino's Problem\n$ Problem details available in:\n$   The OPL Optimization Programming Language\n$   Pascal Van Hentenryck\n$   MIT Press, January 1999.\n$\n$ 27 July 2007\n$\n \ngiven maxMaterial : int\n \n$ Material: there are five different types of materials\n$ Colour: there are three different types of bin, distinguished by colour\nletting Material be new type enum {glass,plastic,steel,wood,copper},\n        Colour be new type enum {red,green,blue}\n \n$ quantity: the amount of each material that is required to be placed in bins\n$ capacity: each bin type (colour) has a certain capacity\ngiven quantity : function (total) Material --> int(0..),\n      capacity : function (total) Colour --> int(0..)\n \n$ Bin: bins are represented by an unnamed type. the number of values is the same\n$      as the total amount of material that is required\nletting Bin be new type of size (sum m : Material . quantity(m))\n \n$ colour: each bin is assigned a colour\n$ contents: the contents of each bin is a multiset of materials\nfind colour : function Bin --> Colour,\n     $ The size of each mset returned by contents is <= some value returned by capacity (given)\n     contents : function Bin --> mset (maxOccur maxMaterial, maxSize max(range(capacity))) of Material\n \n$ minimise the number of bins that have colours & materials assigned to them\nminimising |defined(colour)|\n \nsuch that\n$ every bin that has a colour, must also have a contents, and vice versa\n    forAll b : Bin . b in defined(colour) <-> b in defined(contents),\n$ the correct amount of each material is spread across all the bins\n    forAll m : Material . (sum b in defined(contents) . freq(contents(b),m))\n                          = quantity(m),\n$ the amount of material in each bin does not exceed its capacity\n    forAll b in defined(colour) . |contents(b)| <= capacity(colour(b)),\n$ red bins cannot contain plastic or steel\n    forAll b in defined(colour) . colour(b) = red ->\n                                   !(plastic in contents(b)) /\\\n                                   !(steel in contents(b)),\n$ blue bins cannot contain wood or plastic\n    forAll b in defined(colour) . colour(b) = blue ->\n                                   !(wood in contents(b)) /\\\n                                   !(plastic in contents(b)),\n$ green bins cannot contain steel or glass\n    forAll b in defined(colour) . colour(b) = green ->\n                                   !(steel in contents(b)) /\\\n                                   !(glass in contents(b)),\n$ red bins contain at most one wooden component\n    forAll b in defined(colour) . colour(b) = red ->\n                                   freq(contents(b),wood) <= 1,\n$ green bins contain at most two wooden components\n    forAll b in defined(colour) . colour(b) = green ->\n                                   freq(contents(b),wood) <= 2,\n$ wood requires plastic\n    forAll b in defined(colour) . wood in contents(b) ->\n                                   plastic in contents(b),\n$ glass excludes copper\n    forAll b in defined(colour) . glass in contents(b) ->\n                                   !(copper in contents(b)),\n$ copper excludes plastic\n    forAll b in defined(colour) . copper in contents(b) ->\n                                   !(plastic in contents(b))\n======\nDescription 1:\n------\nVellino's Problem\n\nThis problem is about packing different materials into bins of different colors. Imagine you have five types of materials (glass, plastic, steel, wood, and copper) and three types of bins (red, green, and blue). Each bin can hold a certain amount of material, and you need to put the right amount of each material into the bins.\n\nThe main variables are:\n\n* Materials: the five types of materials (glass, plastic, steel, wood, and copper)\n* Bins: the containers where the materials will be placed\n* Colour: the color of each bin (red, green, or blue)\n* Contents: the materials that are placed in each bin\n\nThe basic restrictions or rules of the problem are:\n\n* Each bin can only hold a certain amount of material\n* Certain materials cannot be placed in certain colored bins (e.g., plastic cannot be placed in red bins)\n* Some materials require other materials to be present (e.g., wood requires plastic)\n* Some materials exclude other materials (e.g., glass excludes copper)\n\nThe goal of the problem is to minimize the number of bins that are used to pack all the materials. In other words, we want to use as few bins as possible to pack all the materials while following the rules and restrictions.\n======\nDescription 2:\n------\nVellino's Problem\n\nVellino's Problem is a classic constraint programming problem that involves assigning materials to bins of different colors, subject to various constraints.\n\nThe main decision variables in this problem are:\n\n* `colour`: a function that assigns a color (red, green, or blue) to each bin\n* `contents`: a function that assigns a multiset of materials to each bin\n\nThe key constraints in this problem are:\n\n* Each bin must have a color and contents, or neither\n* The total amount of each material must be spread across all bins\n* The amount of material in each bin cannot exceed its capacity\n* Certain materials are incompatible with certain bin colors (e.g., red bins cannot contain plastic or steel)\n* Certain materials have specific requirements (e.g., wood requires plastic, glass excludes copper)\n* Some bins have limits on the number of wooden components they can contain\n\nThe objective of this problem is to minimize the number of bins that have colors and materials assigned to them.\n\nIn essence, Vellino's Problem is a complex bin packing problem with additional constraints on material compatibility and requirements. It requires finding an optimal assignment of materials to bins that satisfies all the constraints and minimizes the number of used bins.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 5871, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "94fbf166-ce6e-4a3f-8851-c7b901d27a20": {"__data__": {"id_": "94fbf166-ce6e-4a3f-8851-c7b901d27a20", "embedding": null, "metadata": {"model_name": "wagner"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "wagner_beginner_medium", "node_type": "4", "metadata": {"model_name": "wagner"}, "hash": "a3e150929e04713a8266d4d55216660bc6e666f55d39f34473767be7c988d276", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n------\nlanguage Essence 1.3\n \n$ ** Updates **\n$ 2021/08/04 - The new model 'DistributionWagnerWhitin-partialfunc.essence' performances\n$              signficantly better in practice.\n \n$ Problem Wagner-Whitin Distribution\n$\n$ Problem details available at http://www.csplib.org/Problems/prob040/\n$\n$ Essence model by Andrew Martin\n$\n$ Licenced under CC-BY-4.0 : http://creativecommons.org/licenses/by/4.0/\n \n$ in this model, rather than define multiple levels, children of each node are defined explicitly\n \ngiven numNodes : int(1..)\n \n$ leaves are always first numLeaves nodes\n$ leaves cannot have any children\ngiven numLeaves : int(1..)\n \n$ period 0 is empty, all stock is 0\ngiven numPeriods : int(1..)\n \n$ used to provide bound to output\ngiven maxStock : int(1..)\n \nletting dNodes be domain int(1..numNodes)\nletting dLeaves be domain int(1..numLeaves)\nletting dAllPeriods be domain int(0..numPeriods)\nletting dPeriods be domain int(1..numPeriods)\n \ngiven holdingCost : matrix indexed by [dNodes] of int(0..)\n \ngiven procCost : matrix indexed by [dNodes] of int(0..)\n \ngiven demand : matrix indexed by [dLeaves, dPeriods] of int(0..)\n \n$ used to determine where supply comes goes to\ngiven children : matrix indexed by [dNodes] of set of dNodes\n \nfind orders : matrix indexed by [dNodes, dPeriods] of int(0..maxStock)\n \n$ AUX find statement\nfind stock : matrix indexed by [dNodes, dAllPeriods] of int(0..maxStock)\n \n$ minimising the cost\n$ holding*stock per period per node plus proc if any orders were placed per period per node\nminimising (sum t : dPeriods . (sum i : dNodes . (holdingCost[i] * stock[i][t] + procCost[i] * toInt(orders[i][t] > 0))))\n \n \nsuch that\n \n$ stock starts at 0\n    forAll i : dNodes .\n        stock[i][0] = 0\n,\n$ non-leaf constraints - orders coming from children must be fulfilled\n    forAll t : dPeriods .\n        forAll i : int(numLeaves+1..numNodes) .\n            stock[i][t] = stock[i][t-1] + orders[i][t] - (sum m in children[i] . orders[m][t])\n,\n$ leaf constraints - demands must be fullfilled\n    forAll t : dPeriods .\n        forAll i : dLeaves .\n            stock[i][t] = stock[i][t-1] + orders[i][t] - demand[i][t]\n======\nDescription 1:\n------\nWagner-Whitin Distribution Problem\n\nThis problem is about managing inventory and supply chain for a company that produces goods. Imagine a company that makes products and needs to store them in warehouses. The company wants to minimize the cost of storing and producing these products while making sure it has enough stock to meet customer demand.\n\nThe main variables are:\n\n* `orders`: the amount of products to order from each warehouse in each time period\n* `stock`: the amount of products stored in each warehouse in each time period\n\nThe basic restrictions or rules of the problem are:\n\n* The company starts with no stock in any warehouse\n* The company must fulfill customer demand for each product in each time period\n* The company can only supply products to its customers from its warehouses\n* The company wants to minimize the cost of storing and producing products\n\nThe goal of the problem is to minimize the total cost of storing and producing products while meeting customer demand. The cost includes the cost of holding products in stock and the cost of producing new products to meet demand.\n======\nDescription 2:\n------\nWagner-Whitin Distribution Problem\n\nThe Wagner-Whitin Distribution Problem is a classic constraint programming problem that involves managing inventory and distribution in a supply chain. It is a multi-period problem, meaning that decisions are made over a series of time periods.\n\nThe main decision variables in this problem are:\n\n* `orders`: a matrix that represents the quantity of inventory ordered at each node (location) in each period.\n* `stock`: a matrix that represents the inventory level at each node in each period.\n\nThe key constraints in this problem are:\n\n* The initial inventory level at each node is zero.\n* The inventory level at each non-leaf node (i.e., a node that has children) in each period is equal to the previous period's inventory level plus the quantity ordered minus the total quantity shipped to its children.\n* The inventory level at each leaf node (i.e., a node that has no children) in each period is equal to the previous period's inventory level plus the quantity ordered minus the demand in that period.\n\nThe objective of the problem is to minimize the total cost, which consists of two components:\n\n* Holding cost: the cost of holding inventory at each node in each period.\n* Procurement cost: the cost of ordering inventory at each node in each period.\n\nThe problem is to determine the optimal ordering and inventory levels at each node in each period to meet the demand while minimizing the total cost.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4771, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "221c9722-87c0-4ca0-98c9-d9b6965c5e78": {"__data__": {"id_": "221c9722-87c0-4ca0-98c9-d9b6965c5e78", "embedding": null, "metadata": {"model_name": "word_design"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "word_design_beginner_medium", "node_type": "4", "metadata": {"model_name": "word_design"}, "hash": "5b4d3220ee431e586d82293e092f01fc3f9b7716a6faf39ef537398fb4dc93dc", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n------\nlanguage Essence 1.3\n$ prob033.essence: Word Design for DNA Computing on Surfaces\n$ Problem details available at http://www.csplib.org/Problems/prob033/\n \nletting Base be new type enum {A,C,G,T},\n        Index be domain int(1..8)\n \n$ Notice: The problem specification states that we are trying to find a set of words.\n$ We take this literally, and do not allow repeated words.\n \nfind words : set of function (total) Index --> Base\n \nmaximising |words|\n \nsuch that\n \n    $ Each word in S has 4 symbols from (C, G)\n    forAll w in words . |preImage(w,C)| + |preImage(w,G)| = 4,\n \n    $ Each pair of words in S differ in at least 4 positions\n    forAll {w1,w2} subsetEq words .\n        (sum i : Index . toInt(w1(i) != w2(i))) >= 4,\n \n    forAll {w1,w2} subsetEq words .\n        (sum i : Index .\n            $\n            $ To decide whether they are identical at index i, we need to inspect the values of w1(9-i) and w2(i).\n            $ This is because w1 is reversed, and w2 is the Watson-Crick complement.\n            $\n            $ Watson-Crick complementing is implemented by listing a set of allowed pairs.\n            $ If the pair is a member of the set of allowed pairs, they are identical.\n            $\n            $ We require that they are not identical (hence the negation) in at least 4 positions.\n            $\n            toInt(! ((w1(9-i), w2(i)) in {(A,T), (C,G), (G,C), (T,A)}) )\n        ) >= 4\n======\nDescription 1:\n------\nDNA Word Design Problem\n\nThis problem is about designing a set of special words that can be used in DNA computing on surfaces. Imagine you have a set of Lego blocks with four different shapes (A, C, G, and T) and you want to build a collection of short words using these blocks.\n\nThe main variables are the words, which are like short sequences of these Lego blocks. Each word has 8 blocks, and each block can be one of the four shapes.\n\nThe basic restrictions or rules of the problem are:\n\n* Each word must have exactly 4 blocks that are either C or G.\n* Any two words in the collection must be different in at least 4 positions.\n* When you reverse one word and compare it to another word, they must be different in at least 4 positions, following some specific rules about which blocks can be paired together (like A can be paired with T, and C can be paired with G).\n\nThe goal of the problem is to find the largest possible collection of words that follow these rules.\n======\nDescription 2:\n------\n**Word Design for DNA Computing on Surfaces**\n\nThis problem is about designing a set of words, where each word is a sequence of 8 DNA bases (A, C, G, and T), such that the words satisfy certain constraints.\n\n**Decision Variables:**\nThe main decision variable is `words`, which is a set of functions that map each index (1 to 8) to a DNA base (A, C, G, or T). Each function represents a word.\n\n**Key Constraints:**\n\n1. **Each word has 4 symbols from {C, G}:** Each word must contain exactly 4 occurrences of either C or G.\n2. **Each pair of words differs in at least 4 positions:** Any two words in the set must have at least 4 different bases at different positions.\n3. **No two words are reverse complements:** For any two words, there must be at least 4 positions where the reverse complement of one word is not identical to the other word.\n\n**Objective:**\nThe objective is to **maximize the number of words** in the set that satisfy the constraints.\n\nIn essence, this problem is about finding the largest possible set of DNA words that meet certain criteria, such as having a specific number of C and G bases, being distinct from each other, and not being reverse complements of each other.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3656, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"knapsack_beginner_medium": {"node_ids": ["66a5facf-6b54-4379-bd2e-341bb52a92b4"], "metadata": {"model_name": "knapsack"}}, "lam_beginner_medium": {"node_ids": ["058184eb-c0a1-4e9b-abdf-f53828706b68"], "metadata": {"model_name": "lam"}}, "low_autocorrel_beginner_medium": {"node_ids": ["16985e54-11d1-46cf-93e3-edefc0507d58"], "metadata": {"model_name": "low_autocorrel"}}, "magic_hexagon_beginner_medium": {"node_ids": ["36f2173b-5381-4279-bf29-f699147788da"], "metadata": {"model_name": "magic_hexagon"}}, "ppp_beginner_medium": {"node_ids": ["064f6800-0abc-4b6e-ba17-c91392040301"], "metadata": {"model_name": "ppp"}}, "rag_config_beginner_medium": {"node_ids": ["ddb65ea4-e15f-47b7-b7e7-2f5b4b59169f"], "metadata": {"model_name": "rag_config"}}, "ramsey_beginner_medium": {"node_ids": ["493d1fee-70fc-4d6a-b845-e7d0ffebb2f8"], "metadata": {"model_name": "ramsey"}}, "vellino_beginner_medium": {"node_ids": ["84a6cada-d0bd-41ac-98a1-cc34d7d938d8"], "metadata": {"model_name": "vellino"}}, "wagner_beginner_medium": {"node_ids": ["94fbf166-ce6e-4a3f-8851-c7b901d27a20"], "metadata": {"model_name": "wagner"}}, "word_design_beginner_medium": {"node_ids": ["221c9722-87c0-4ca0-98c9-d9b6965c5e78"], "metadata": {"model_name": "word_design"}}}}