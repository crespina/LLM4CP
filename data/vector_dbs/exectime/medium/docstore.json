{"docstore/metadata": {"knapsack_medium": {"doc_hash": "ce0650544ef50dab54487d4a3104d9f579cfaa2e14b060677de2df5fe2dc44f8"}, "lam_medium": {"doc_hash": "f7ec2b30589b62d3cfca0b509e25b8fc72b07c675b5adbba8e72b6a7f618a0b8"}, "low_autocorrel_medium": {"doc_hash": "5bc89caeeceb8388af4f5dd4dd8b3d56ca1a01295a2295beac63a952e44a49ee"}, "magic_hexagon_medium": {"doc_hash": "d8e2c1f89dfd3d857aa23e4741166bbfb42b396fd0a9330fca135994693abeb4"}, "ppp_medium": {"doc_hash": "b79c9332875ab4bc23097a006c4148ce222f68d64700feaffcf1199d3fabc7ce"}, "rag_config_medium": {"doc_hash": "0b48b5a66f4feb14592a7c6c69e8f63b3fc1c7c7598f52aaec6df24cf6619d71"}, "ramsey_medium": {"doc_hash": "d3c28b1bd95ed95cda7ba4e8a4ff89bac563ea3a7f0dc3367005dff94baabc89"}, "vellino_medium": {"doc_hash": "7045b69731f57aca51d68ecab7c3f1b7b606c59bf695b31f173838ae9ea603d1"}, "wagner_medium": {"doc_hash": "4a726f5394c52e8fe590ec48e1fc2dbb373a6e14cfd84cc453daf0646803aec3"}, "word_design_medium": {"doc_hash": "91cf8c027d7eb6328755cee246721062208da1439764efd2ddb0e16dded43d88"}, "0dbb7f8b-f411-4828-afdd-88658b6cb5ba": {"doc_hash": "ce0650544ef50dab54487d4a3104d9f579cfaa2e14b060677de2df5fe2dc44f8", "ref_doc_id": "knapsack_medium"}, "95758db4-5a07-4cd2-b839-abbcd8318e66": {"doc_hash": "f7ec2b30589b62d3cfca0b509e25b8fc72b07c675b5adbba8e72b6a7f618a0b8", "ref_doc_id": "lam_medium"}, "433c74f2-8a58-4bc6-a3c4-b06adfb047c9": {"doc_hash": "5bc89caeeceb8388af4f5dd4dd8b3d56ca1a01295a2295beac63a952e44a49ee", "ref_doc_id": "low_autocorrel_medium"}, "02f6444b-7edb-493d-9537-82990aca05f1": {"doc_hash": "d8e2c1f89dfd3d857aa23e4741166bbfb42b396fd0a9330fca135994693abeb4", "ref_doc_id": "magic_hexagon_medium"}, "b3cc7b1f-2b44-44a8-8911-5ab29039e0a8": {"doc_hash": "b79c9332875ab4bc23097a006c4148ce222f68d64700feaffcf1199d3fabc7ce", "ref_doc_id": "ppp_medium"}, "4933f332-5140-454c-a897-d4a2cd8cb666": {"doc_hash": "0b48b5a66f4feb14592a7c6c69e8f63b3fc1c7c7598f52aaec6df24cf6619d71", "ref_doc_id": "rag_config_medium"}, "12e32fd5-7122-472d-9498-f3ad4c826260": {"doc_hash": "d3c28b1bd95ed95cda7ba4e8a4ff89bac563ea3a7f0dc3367005dff94baabc89", "ref_doc_id": "ramsey_medium"}, "d177f67f-ebd9-4f8a-bc7b-12c74da55418": {"doc_hash": "7045b69731f57aca51d68ecab7c3f1b7b606c59bf695b31f173838ae9ea603d1", "ref_doc_id": "vellino_medium"}, "a1dcec0e-5cf2-4341-b301-8a9c7369da94": {"doc_hash": "4a726f5394c52e8fe590ec48e1fc2dbb373a6e14cfd84cc453daf0646803aec3", "ref_doc_id": "wagner_medium"}, "37e39dc9-9f16-4d66-a963-7a8e8ad30791": {"doc_hash": "91cf8c027d7eb6328755cee246721062208da1439764efd2ddb0e16dded43d88", "ref_doc_id": "word_design_medium"}}, "docstore/data": {"0dbb7f8b-f411-4828-afdd-88658b6cb5ba": {"__data__": {"id_": "0dbb7f8b-f411-4828-afdd-88658b6cb5ba", "embedding": null, "metadata": {"model_name": "knapsack"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "knapsack_medium", "node_type": "4", "metadata": {"model_name": "knapsack"}, "hash": "ce0650544ef50dab54487d4a3104d9f579cfaa2e14b060677de2df5fe2dc44f8", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language Essence 1.3\n$ prob133.essence: Knapsack Problem\n \ngiven items new type enum\ngiven weight, gain : function (total) items --> int\ngiven capacity : int\nfind picked : set of items\nmaximising sum i in picked . gain(i)\nsuch that (sum i in picked . weight(i)) <= capacity\n            ======\n            Description:\n            ---------\n            The 0/1 Knapsack Problem.\n\nThis problem is about selecting a subset of items to include in a knapsack of limited capacity, with the goal of maximizing the total value of the selected items while not exceeding the knapsack's weight capacity.\n\nThe main decision variables are the elements of the set `picked`, which represent the items that are selected to be included in the knapsack.\n\nThe key constraints are:\n\n* The total weight of the selected items must not exceed the knapsack's capacity.\n* Each item is either selected (included in the knapsack) or not selected.\n\nThe objective is to maximize the total gain (or value) of the selected items.\n\nIn essence, the problem is about making a selection of items that provides the highest value while staying within the weight constraints of the knapsack.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1197, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "95758db4-5a07-4cd2-b839-abbcd8318e66": {"__data__": {"id_": "95758db4-5a07-4cd2-b839-abbcd8318e66", "embedding": null, "metadata": {"model_name": "lam"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "lam_medium", "node_type": "4", "metadata": {"model_name": "lam"}, "hash": "f7ec2b30589b62d3cfca0b509e25b8fc72b07c675b5adbba8e72b6a7f618a0b8", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language Essence 1.3\n$ prob025.essence: Lam's Problem\n$ Problem details available at http://www.csplib.org/Problems/prob025/\n \ngiven indexSize: int\n \nletting Index be new type of size indexSize\n \nfind m: matrix indexed by [Index,Index] of bool\n \nsuch that\n    forAll r : Index\n        . (sum c : Index . toInt(!m[r,c])) = 11,\n    forAll c : Index\n        . (sum r : Index . toInt(!m[r,c])) = 11,\n    forAll r1,r2 : Index , r1 != r2\n        . (sum c : Index . toInt(!(m[r1,c] \\/ m[r2,c]))) = 1\n\n            ======\n            Description:\n            ---------\n            Lam's Problem.\n\nLam's Problem is a classic constraint programming problem that involves finding a matrix of boolean values that satisfies certain constraints. The problem is about constructing a matrix with specific properties, which makes it a challenging and interesting problem in the field of constraint programming.\n\nThe main decision variables in this problem are the elements of the matrix `m`, which is a matrix indexed by `Index` and `Index`, where `Index` is a type of size `indexSize`. Each element `m[r,c]` represents a boolean value that indicates whether a certain condition is true or false.\n\nThe key constraints in this problem can be described as follows:\n\n* Each row of the matrix must sum up to 11, meaning that exactly 11 elements in each row must be true.\n* Each column of the matrix must sum up to 11, meaning that exactly 11 elements in each column must be true.\n* For any two distinct rows `r1` and `r2`, there must be exactly one column `c` such that either `m[r1,c]` or `m[r2,c]` is true, but not both.\n\nThe objective of this problem is to find a matrix that satisfies all these constraints. There is no explicit objective function to minimize or maximize, as the goal is to find a feasible solution that meets all the constraints.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1873, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "433c74f2-8a58-4bc6-a3c4-b06adfb047c9": {"__data__": {"id_": "433c74f2-8a58-4bc6-a3c4-b06adfb047c9", "embedding": null, "metadata": {"model_name": "low_autocorrel"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "low_autocorrel_medium", "node_type": "4", "metadata": {"model_name": "low_autocorrel"}, "hash": "5bc89caeeceb8388af4f5dd4dd8b3d56ca1a01295a2295beac63a952e44a49ee", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language Essence 1.3\n$ prob005.essence: Low Autocorrellation Binary Sequences\n$ Problem details available at http://www.csplib.org/Problems/prob005/\n \ngiven n : int(1..)\n \nfind seq : function (total) int(1..n) --> int(-1,1)\n \nminimising sum k : int(1..n) . (sum i : int(1..n-k) . seq(i) * seq(i+k)) ** 2\n            ======\n            Description:\n            ---------\n            Low Autocorrelation Binary Sequences Problem.\n\nThis problem is about finding a binary sequence of length `n` with the lowest possible autocorrelation. In other words, we want to find a sequence of `+1` and `-1` values where the correlation between the sequence and its shifted versions is minimized.\n\nThe main decision variable is `seq`, a function that assigns a value of `+1` or `-1` to each position in the sequence.\n\nThe key constraints are:\n\n* The sequence must have a length of `n`.\n* Each element in the sequence must be either `+1` or `-1`.\n\nThe objective is to minimize the sum of the squared autocorrelations of the sequence. Autocorrelation is a measure of how similar a sequence is to its shifted versions. In this problem, we calculate the autocorrelation by multiplying corresponding elements of the sequence and its shifted versions, summing these products, and then squaring the result. The goal is to find a sequence that has the lowest possible sum of these squared autocorrelations.\n\nIn essence, this problem is about finding a binary sequence that is as dissimilar as possible to its own shifted versions, which has applications in various fields such as signal processing, coding theory, and cryptography.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1652, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "02f6444b-7edb-493d-9537-82990aca05f1": {"__data__": {"id_": "02f6444b-7edb-493d-9537-82990aca05f1", "embedding": null, "metadata": {"model_name": "magic_hexagon"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "magic_hexagon_medium", "node_type": "4", "metadata": {"model_name": "magic_hexagon"}, "hash": "d8e2c1f89dfd3d857aa23e4741166bbfb42b396fd0a9330fca135994693abeb4", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language ESSENCE 1.2.0\n$ prob023.essence: Magic Hexagon\n$ Problem details available at http://www.csplib.org/Problems/prob023/\n$ 03 September 2007\n$\n \n$ d: the diameter of the hexagon (length of the longest row)\ngiven d : int(1..)\n \n$ d must be an odd integer\nwhere d % 2 = 1\n \n$ o: the order of the hexagon (length of the shortest row)\n$ maxval: the maximum value that will appear in the hexagon\n$ maxsum: the maximum value that a row could sum to\n$ Value: the domain consisting of the integers contained in the hexagon\nletting o be d/2 + 1,\n        maxval be 3 * o**2 - 3 * o + 1,\n        maxsum be sum i : int(maxval + 1 - d..maxval) . i,\n        Value be domain int(1..maxval)\n \n$ hexagon: the hexagon is represented by a matrix. for any row i, we are only\n$          interested in the first d - |d/2 + 1 - i| elements of the row\n$ s: the magic number that all rows and diagonals sum to\nfind hexagon : matrix indexed by [int(1..d),int(1..d)] of Value,\n     s : int(1..maxsum)\n \nsuch that\n$ all elements are different (and therefore all values are included)\n    forAll r1,r2 : int(1..d) . forAll i1 : int(1..d - |o - r1|) .\n        forAll i2 : int(1..d - |o - r2|) . r1 != r2 \\/ i1 != i2 ->\n            hexagon[r1,i1] != hexagon[r2,i2],\n$ all rows sum to s\n    forAll r : int(1..d) . (sum i : int(1..d - |o - r|) . hexagon[r,i]) = s,\n$ all right-sloping diagonals sum to s\n    forAll r : int(1..d) . (sum i : int(1..d - |o - r|) .\n        hexagon[i + max({0,o-r}), r - max({0,o-(i + max({0,o-r}))})]) = s,\n$ all left-sloping diagonals sum to s\n    forAll r : int(1..d) . (sum i : int(1..d - |o - r|) .\n        hexagon[i + max({0,r-o}), r - max({0,(i + max({0,r-o}))-o})]) = s\n            ======\n            Description:\n            ---------\n            Magic Hexagon Problem.\n\nThe Magic Hexagon problem is a classic constraint programming problem that involves creating a hexagonal arrangement of numbers such that each row, column, and diagonal sums up to a specific magic number.\n\nThe main decision variables in this problem are:\n\n* `hexagon`: a matrix representing the hexagonal arrangement of numbers, where each element is an integer between 1 and `maxval`.\n* `s`: the magic number that all rows and diagonals sum up to.\n\nThe key constraints in this problem are:\n\n* Each element in the hexagon is unique (i.e., all numbers from 1 to `maxval` are used exactly once).\n* Each row in the hexagon sums up to the magic number `s`.\n* Each right-sloping diagonal in the hexagon sums up to the magic number `s`.\n* Each left-sloping diagonal in the hexagon sums up to the magic number `s`.\n\nThe objective of this problem is to find a valid hexagonal arrangement that satisfies all the constraints, without any specific optimization goal (i.e., it's a satisfaction problem rather than an optimization problem).", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2852, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b3cc7b1f-2b44-44a8-8911-5ab29039e0a8": {"__data__": {"id_": "b3cc7b1f-2b44-44a8-8911-5ab29039e0a8", "embedding": null, "metadata": {"model_name": "ppp"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ppp_medium", "node_type": "4", "metadata": {"model_name": "ppp"}, "hash": "b79c9332875ab4bc23097a006c4148ce222f68d64700feaffcf1199d3fabc7ce", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language Essence 1.3\n$ prob013.essence: Progressive Party Problem\n$ Problem details available at http://www.csplib.org/Problems/prob013/\n \ngiven n_boats, n_periods : int(1..)\n \nletting Boat be domain int(1..n_boats)\n \ngiven capacity, crew : function (total) Boat --> int(1..)\n \nfind hosts : set (minSize 1) of Boat,\n     sched : set (size n_periods) of partition from Boat\n \nminimising |hosts|\n \n$ Hosts remain the same throughout the schedule\nsuch that\n    forAll p in sched . |parts(p)| = |hosts| /\\\n    forAll part in parts(p) . |part intersect hosts| = 1\n \n$ Hosts have the capacity to support the visiting crews\nsuch that forAll p in sched . forAll h in hosts .\n    (sum b in party(h,p) . crew(b)) <= capacity(h)\n \nsuch that allDiff([ (i, j)\n                  | p <- sched\n                  , part <- p\n                  , {i,j} <- powerSet(part)\n                  ])\n            ======\n            Description:\n            ---------\n            Progressive Party Problem.\n\nThis problem is about organizing a series of parties where a set of boats with different capacities need to host crews of varying sizes over multiple periods. The goal is to minimize the number of boats required to host all the crews while ensuring that each boat has the capacity to support the visiting crews and that each crew is assigned to a unique boat in each period.\n\nThe main decision variables are:\n\n* `hosts`: a set of boats that will be used to host the crews\n* `sched`: a schedule that assigns each boat to a period and divides the boats into partitions (or groups) for each period\n\nThe key constraints are:\n\n* Each period must have the same number of partitions (or groups) as the number of hosts.\n* Each partition in each period must contain exactly one host.\n* The total crew size assigned to each host in each period must not exceed the host's capacity.\n* Each pair of boats must be assigned to different partitions in each period (i.e., no two boats can be in the same partition).\n\nThe objective is to minimize the number of hosts (boats) required to host all the crews.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2111, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4933f332-5140-454c-a897-d4a2cd8cb666": {"__data__": {"id_": "4933f332-5140-454c-a897-d4a2cd8cb666", "embedding": null, "metadata": {"model_name": "rag_config"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "rag_config_medium", "node_type": "4", "metadata": {"model_name": "rag_config"}, "hash": "0b48b5a66f4feb14592a7c6c69e8f63b3fc1c7c7598f52aaec6df24cf6619d71", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language Essence 1.3\n$ prob031.essence: Rack Configuration Problem\n$ Problem details available at http://www.csplib.org/Problems/prob031/\n \n$ We are using the problem description from the following paper very closely here.\n$ \"Symmetry Breaking in a Rack Configuration Problem\" Zeynep K\u0131z\u0131ltan and Brahim Hnich\n \n \n \n$ The rack configuration problem consists of plugging a set of electronic cards\n$ into racks with electronic connectors.\ngiven nbRacks : int(1..)\nletting Rack be new type of size nbRacks\n \n$ Each card belongs to a certain card type.\ngiven nbTypes : int(1..)\nletting Type be domain int(1..nbTypes)\n \n$ A card type is characterised by the power it requires, ...\ngiven requiredPower : function (total) Type --> int(1..)\n \n$ ... and a demand, which designates how many cards of that type have to be plugged.\ngiven demand : function (total) Type --> int(1..)\n \n \n$ In order to plug a card into a rack, the rack needs to use a rack model.\ngiven nbModels : int\nletting Model be domain int(1..nbModels)\n \n$ Each rack model is characterised by the maximal power it can supply, its number of connectors, and its price.\ngiven maxPower      : function (total) Model --> int(1..)\ngiven maxConnectors : function (total) Model --> int(1..)\ngiven price         : function (total) Model --> int(1..)\n \n$ A rack model can be used by any rack.\n$ Each card plugged into a rack uses a connector.\n$ The problem is to decide how many of the available racks are needed,\n$ and which rack models the racks use in order to plug all the cards\n$ such that the total price is minimised.\n \nfind configuration :\n        function Rack -->\n            $ the model for this rack\n            ( Model\n            $ for each type, the number of cards of that type\n            , function (total) Type --> int(0..max(range(maxConnectors)))\n            )\n \n \n$ The constraints of the problem and the cost function can be summarised as the following:\n \n$ The connector-capacity constraint:\n$ the number of cards plugged into a rack r\n$ must not exceed the number of connectors of the rack model used by r.\nsuch that\n    forAll (rack, (model, counts)) in configuration .\n        sum([ num | (ty, num) <- counts ]) <= maxConnectors(model)\n \n$ The power-capacity constraint:\n$ the total power of the cards plugged into a rack r\n$ must not exceed the power of the rack model used by r.\nsuch that\n    forAll (rack, (model, counts)) in configuration .\n        sum([ requiredPower(ty) * num | (ty, num) <- counts ]) <= maxPower(model)\n \n$ The demand constraint: all the cards have to be plugged into some rack.\nsuch that\n    forAll (ty, tyDemand) in demand .\n        tyDemand <= sum([ num\n                        | (rack, (model, counts)) <- configuration\n                        , (ty2, num) <- counts\n                        , ty = ty2\n                        ])\n \n$ The cost function is the sum of the prices of the rack models used by all the racks needed.\nfind totalCost : int(0.. |Rack| * |Model| * max(range(price)) )\nsuch that totalCost = sum (rack, (model, counts)) in configuration . price(model)\nminimising totalCost\n            ======\n            Description:\n            ---------\n            Rack Configuration Problem\n\nThe Rack Configuration Problem is a classic constraint programming problem that involves configuring racks to plug in electronic cards of different types. The goal is to minimize the total cost of the rack models used while satisfying the power and connector capacity constraints.\n\nThe main decision variables in this problem are:\n\n* `configuration`: a function that assigns a rack model and a set of card counts to each rack. The card counts represent the number of cards of each type plugged into the rack.\n\nThe key constraints in this problem are:\n\n* Connector-capacity constraint: The total number of cards plugged into a rack cannot exceed the number of connectors available on the rack model used.\n* Power-capacity constraint: The total power required by the cards plugged into a rack cannot exceed the power capacity of the rack model used.\n* Demand constraint: All cards of each type must be plugged into some rack, satisfying the demand for each card type.\n\nThe objective of the problem is to minimize the total cost of the rack models used, which is calculated by summing the prices of the rack models assigned to each rack.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4379, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "12e32fd5-7122-472d-9498-f3ad4c826260": {"__data__": {"id_": "12e32fd5-7122-472d-9498-f3ad4c826260", "embedding": null, "metadata": {"model_name": "ramsey"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ramsey_medium", "node_type": "4", "metadata": {"model_name": "ramsey"}, "hash": "d3c28b1bd95ed95cda7ba4e8a4ff89bac563ea3a7f0dc3367005dff94baabc89", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language Essence 1.3\n \n$ The Ramsey number R(k,l) is the smallest number such that\n$ if we two-colour the edges of complete graph of this size,\n$ there always exists a monochromatic subgraph of either k or l nodes.\n \n$ In other words (from Wikipedia):\n$ The Ramsey number, R(k,l), gives the solution to the party problem,\n$ which asks the minimum number of guests, R(k,l), that must be invited\n$ so that at least k will know each other\n$      or at least l will not know each other.\n \n$ Here, we are modelling the Ramsey-graph problem which is the problem of finding counter-examples.\n$ For a given k,l, and num_vertices: find a colouring of the complete graph\n$ which does not have a blue-subgraph nor a red-subgraph.\n \ngiven k, l, num_vertices : int\n \n$ due to symmetry R(k, l) = R(l,k)\nwhere k <= l\n \n$ complete graph, to we can calculate the number of edges\nletting num_edges be num_vertices * (num_vertices - 1)\n \n$ we are two-colouring\nletting Colour be new type enum {red, blue}\n \nletting Vertex be domain int(1..num_vertices)\n \nfind graph : function (size num_edges) (Vertex, Vertex) --> Colour\n \n \n$ the graph is complete\nsuch that\n    forAll i,j : Vertex . i < j ->\n        (i,j) in defined(graph) /\\ graph((i,j)) = graph((j,i)),\n    forAll i : Vertex .\n        !((i,i) in defined(graph))\n \n \n$ there isn't a red-subgraph of size k\nsuch that\n    forAll subgraph_vertices : set (size k) of Vertex .\n        !(forAll {i,j} subsetEq subgraph_vertices . graph((i,j)) = red)\n \n \n$ there isn't a blue-subgraph of size l\nsuch that\n    forAll subgraph_vertices : set (size l) of Vertex .\n        !(forAll {i,j} subsetEq subgraph_vertices . graph((i,j)) = blue)\n            ======\n            Description:\n            ---------\n            The Ramsey Number Problem.\n\nThe Ramsey Number Problem is a classic problem in graph theory and constraint programming. It's about finding the smallest complete graph that, when its edges are colored with two colors (red and blue), does not contain a monochromatic subgraph of a certain size.\n\nThe main decision variables in this problem are the colors assigned to each edge in the complete graph, represented by the `graph` function. This function takes two vertices as input and returns the color of the edge between them (either red or blue).\n\nThe key constraints in this problem are:\n\n* The graph is complete, meaning every pair of vertices is connected by an edge.\n* The graph is symmetric, meaning the color of the edge between vertices i and j is the same as the color of the edge between vertices j and i.\n* There is no subgraph with k vertices where all edges are red (no red-subgraph of size k).\n* There is no subgraph with l vertices where all edges are blue (no blue-subgraph of size l).\n\nThe objective of this problem is to find a coloring of the complete graph that satisfies these constraints, which means finding a counter-example to the Ramsey number problem.\n\nIn simpler terms, imagine you're hosting a party and you want to invite a minimum number of guests such that either at least k guests know each other or at least l guests don't know each other. The Ramsey Number Problem is about finding the smallest number of guests you need to invite to guarantee this.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3266, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d177f67f-ebd9-4f8a-bc7b-12c74da55418": {"__data__": {"id_": "d177f67f-ebd9-4f8a-bc7b-12c74da55418", "embedding": null, "metadata": {"model_name": "vellino"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "vellino_medium", "node_type": "4", "metadata": {"model_name": "vellino"}, "hash": "7045b69731f57aca51d68ecab7c3f1b7b606c59bf695b31f173838ae9ea603d1", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language ESSENCE 1.2.0\n$ prob116.essence: Vellino's Problem\n$ Problem details available in:\n$   The OPL Optimization Programming Language\n$   Pascal Van Hentenryck\n$   MIT Press, January 1999.\n$\n$ 27 July 2007\n$\n \ngiven maxMaterial : int\n \n$ Material: there are five different types of materials\n$ Colour: there are three different types of bin, distinguished by colour\nletting Material be new type enum {glass,plastic,steel,wood,copper},\n        Colour be new type enum {red,green,blue}\n \n$ quantity: the amount of each material that is required to be placed in bins\n$ capacity: each bin type (colour) has a certain capacity\ngiven quantity : function (total) Material --> int(0..),\n      capacity : function (total) Colour --> int(0..)\n \n$ Bin: bins are represented by an unnamed type. the number of values is the same\n$      as the total amount of material that is required\nletting Bin be new type of size (sum m : Material . quantity(m))\n \n$ colour: each bin is assigned a colour\n$ contents: the contents of each bin is a multiset of materials\nfind colour : function Bin --> Colour,\n     $ The size of each mset returned by contents is <= some value returned by capacity (given)\n     contents : function Bin --> mset (maxOccur maxMaterial, maxSize max(range(capacity))) of Material\n \n$ minimise the number of bins that have colours & materials assigned to them\nminimising |defined(colour)|\n \nsuch that\n$ every bin that has a colour, must also have a contents, and vice versa\n    forAll b : Bin . b in defined(colour) <-> b in defined(contents),\n$ the correct amount of each material is spread across all the bins\n    forAll m : Material . (sum b in defined(contents) . freq(contents(b),m))\n                          = quantity(m),\n$ the amount of material in each bin does not exceed its capacity\n    forAll b in defined(colour) . |contents(b)| <= capacity(colour(b)),\n$ red bins cannot contain plastic or steel\n    forAll b in defined(colour) . colour(b) = red ->\n                                   !(plastic in contents(b)) /\\\n                                   !(steel in contents(b)),\n$ blue bins cannot contain wood or plastic\n    forAll b in defined(colour) . colour(b) = blue ->\n                                   !(wood in contents(b)) /\\\n                                   !(plastic in contents(b)),\n$ green bins cannot contain steel or glass\n    forAll b in defined(colour) . colour(b) = green ->\n                                   !(steel in contents(b)) /\\\n                                   !(glass in contents(b)),\n$ red bins contain at most one wooden component\n    forAll b in defined(colour) . colour(b) = red ->\n                                   freq(contents(b),wood) <= 1,\n$ green bins contain at most two wooden components\n    forAll b in defined(colour) . colour(b) = green ->\n                                   freq(contents(b),wood) <= 2,\n$ wood requires plastic\n    forAll b in defined(colour) . wood in contents(b) ->\n                                   plastic in contents(b),\n$ glass excludes copper\n    forAll b in defined(colour) . glass in contents(b) ->\n                                   !(copper in contents(b)),\n$ copper excludes plastic\n    forAll b in defined(colour) . copper in contents(b) ->\n                                   !(plastic in contents(b))\n            ======\n            Description:\n            ---------\n            Vellino's Problem\n\nVellino's Problem is a classic constraint programming problem that involves assigning materials to bins of different colors, subject to various constraints.\n\nThe main decision variables in this problem are:\n\n* `colour`: a function that assigns a color (red, green, or blue) to each bin\n* `contents`: a function that assigns a multiset of materials to each bin\n\nThe key constraints in this problem are:\n\n* Each bin must have a color and contents, or neither\n* The total amount of each material must be spread across all bins\n* The amount of material in each bin cannot exceed its capacity\n* Certain materials are incompatible with certain bin colors (e.g., red bins cannot contain plastic or steel)\n* Certain materials have specific requirements (e.g., wood requires plastic, glass excludes copper)\n* Some bins have limits on the number of wooden components they can contain\n\nThe objective of this problem is to minimize the number of bins that have colors and materials assigned to them.\n\nIn essence, Vellino's Problem is a complex bin packing problem with additional constraints on material compatibility and requirements. It requires finding an optimal assignment of materials to bins that satisfies all the constraints and minimizes the number of used bins.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4697, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a1dcec0e-5cf2-4341-b301-8a9c7369da94": {"__data__": {"id_": "a1dcec0e-5cf2-4341-b301-8a9c7369da94", "embedding": null, "metadata": {"model_name": "wagner"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "wagner_medium", "node_type": "4", "metadata": {"model_name": "wagner"}, "hash": "4a726f5394c52e8fe590ec48e1fc2dbb373a6e14cfd84cc453daf0646803aec3", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language Essence 1.3\n \n$ ** Updates **\n$ 2021/08/04 - The new model 'DistributionWagnerWhitin-partialfunc.essence' performances\n$              signficantly better in practice.\n \n$ Problem Wagner-Whitin Distribution\n$\n$ Problem details available at http://www.csplib.org/Problems/prob040/\n$\n$ Essence model by Andrew Martin\n$\n$ Licenced under CC-BY-4.0 : http://creativecommons.org/licenses/by/4.0/\n \n$ in this model, rather than define multiple levels, children of each node are defined explicitly\n \ngiven numNodes : int(1..)\n \n$ leaves are always first numLeaves nodes\n$ leaves cannot have any children\ngiven numLeaves : int(1..)\n \n$ period 0 is empty, all stock is 0\ngiven numPeriods : int(1..)\n \n$ used to provide bound to output\ngiven maxStock : int(1..)\n \nletting dNodes be domain int(1..numNodes)\nletting dLeaves be domain int(1..numLeaves)\nletting dAllPeriods be domain int(0..numPeriods)\nletting dPeriods be domain int(1..numPeriods)\n \ngiven holdingCost : matrix indexed by [dNodes] of int(0..)\n \ngiven procCost : matrix indexed by [dNodes] of int(0..)\n \ngiven demand : matrix indexed by [dLeaves, dPeriods] of int(0..)\n \n$ used to determine where supply comes goes to\ngiven children : matrix indexed by [dNodes] of set of dNodes\n \nfind orders : matrix indexed by [dNodes, dPeriods] of int(0..maxStock)\n \n$ AUX find statement\nfind stock : matrix indexed by [dNodes, dAllPeriods] of int(0..maxStock)\n \n$ minimising the cost\n$ holding*stock per period per node plus proc if any orders were placed per period per node\nminimising (sum t : dPeriods . (sum i : dNodes . (holdingCost[i] * stock[i][t] + procCost[i] * toInt(orders[i][t] > 0))))\n \n \nsuch that\n \n$ stock starts at 0\n    forAll i : dNodes .\n        stock[i][0] = 0\n,\n$ non-leaf constraints - orders coming from children must be fulfilled\n    forAll t : dPeriods .\n        forAll i : int(numLeaves+1..numNodes) .\n            stock[i][t] = stock[i][t-1] + orders[i][t] - (sum m in children[i] . orders[m][t])\n,\n$ leaf constraints - demands must be fullfilled\n    forAll t : dPeriods .\n        forAll i : dLeaves .\n            stock[i][t] = stock[i][t-1] + orders[i][t] - demand[i][t]\n            ======\n            Description:\n            ---------\n            Wagner-Whitin Distribution Problem\n\nThe Wagner-Whitin Distribution Problem is a classic constraint programming problem that involves managing inventory and distribution in a supply chain. It is a multi-period problem, meaning that decisions are made over a series of time periods.\n\nThe main decision variables in this problem are:\n\n* `orders`: a matrix that represents the quantity of inventory ordered at each node (location) in each period.\n* `stock`: a matrix that represents the inventory level at each node in each period.\n\nThe key constraints in this problem are:\n\n* The initial inventory level at each node is zero.\n* The inventory level at each non-leaf node (i.e., a node that has children) in each period is equal to the previous period's inventory level plus the quantity ordered minus the total quantity shipped to its children.\n* The inventory level at each leaf node (i.e., a node that has no children) in each period is equal to the previous period's inventory level plus the quantity ordered minus the demand in that period.\n\nThe objective of the problem is to minimize the total cost, which consists of two components:\n\n* Holding cost: the cost of holding inventory at each node in each period.\n* Procurement cost: the cost of ordering inventory at each node in each period.\n\nThe problem is to determine the optimal ordering and inventory levels at each node in each period to meet the demand while minimizing the total cost.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3710, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "37e39dc9-9f16-4d66-a963-7a8e8ad30791": {"__data__": {"id_": "37e39dc9-9f16-4d66-a963-7a8e8ad30791", "embedding": null, "metadata": {"model_name": "word_design"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "word_design_medium", "node_type": "4", "metadata": {"model_name": "word_design"}, "hash": "91cf8c027d7eb6328755cee246721062208da1439764efd2ddb0e16dded43d88", "class_name": "RelatedNodeInfo"}}, "text": "Source code:\n            ------\n            language Essence 1.3\n$ prob033.essence: Word Design for DNA Computing on Surfaces\n$ Problem details available at http://www.csplib.org/Problems/prob033/\n \nletting Base be new type enum {A,C,G,T},\n        Index be domain int(1..8)\n \n$ Notice: The problem specification states that we are trying to find a set of words.\n$ We take this literally, and do not allow repeated words.\n \nfind words : set of function (total) Index --> Base\n \nmaximising |words|\n \nsuch that\n \n    $ Each word in S has 4 symbols from (C, G)\n    forAll w in words . |preImage(w,C)| + |preImage(w,G)| = 4,\n \n    $ Each pair of words in S differ in at least 4 positions\n    forAll {w1,w2} subsetEq words .\n        (sum i : Index . toInt(w1(i) != w2(i))) >= 4,\n \n    forAll {w1,w2} subsetEq words .\n        (sum i : Index .\n            $\n            $ To decide whether they are identical at index i, we need to inspect the values of w1(9-i) and w2(i).\n            $ This is because w1 is reversed, and w2 is the Watson-Crick complement.\n            $\n            $ Watson-Crick complementing is implemented by listing a set of allowed pairs.\n            $ If the pair is a member of the set of allowed pairs, they are identical.\n            $\n            $ We require that they are not identical (hence the negation) in at least 4 positions.\n            $\n            toInt(! ((w1(9-i), w2(i)) in {(A,T), (C,G), (G,C), (T,A)}) )\n        ) >= 4\n            ======\n            Description:\n            ---------\n            **Word Design for DNA Computing on Surfaces**\n\nThis problem is about designing a set of words, where each word is a sequence of 8 DNA bases (A, C, G, and T), such that the words satisfy certain constraints.\n\n**Decision Variables:**\nThe main decision variable is `words`, which is a set of functions that map each index (1 to 8) to a DNA base (A, C, G, or T). Each function represents a word.\n\n**Key Constraints:**\n\n1. **Each word has 4 symbols from {C, G}:** Each word must contain exactly 4 occurrences of either C or G.\n2. **Each pair of words differs in at least 4 positions:** Any two words in the set must have at least 4 different bases at different positions.\n3. **No two words are reverse complements:** For any two words, there must be at least 4 positions where the reverse complement of one word is not identical to the other word.\n\n**Objective:**\nThe objective is to **maximize the number of words** in the set that satisfy the constraints.\n\nIn essence, this problem is about finding the largest possible set of DNA words that meet certain criteria, such as having a specific number of C and G bases, being distinct from each other, and not being reverse complements of each other.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2728, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"knapsack_medium": {"node_ids": ["0dbb7f8b-f411-4828-afdd-88658b6cb5ba"], "metadata": {"model_name": "knapsack"}}, "lam_medium": {"node_ids": ["95758db4-5a07-4cd2-b839-abbcd8318e66"], "metadata": {"model_name": "lam"}}, "low_autocorrel_medium": {"node_ids": ["433c74f2-8a58-4bc6-a3c4-b06adfb047c9"], "metadata": {"model_name": "low_autocorrel"}}, "magic_hexagon_medium": {"node_ids": ["02f6444b-7edb-493d-9537-82990aca05f1"], "metadata": {"model_name": "magic_hexagon"}}, "ppp_medium": {"node_ids": ["b3cc7b1f-2b44-44a8-8911-5ab29039e0a8"], "metadata": {"model_name": "ppp"}}, "rag_config_medium": {"node_ids": ["4933f332-5140-454c-a897-d4a2cd8cb666"], "metadata": {"model_name": "rag_config"}}, "ramsey_medium": {"node_ids": ["12e32fd5-7122-472d-9498-f3ad4c826260"], "metadata": {"model_name": "ramsey"}}, "vellino_medium": {"node_ids": ["d177f67f-ebd9-4f8a-bc7b-12c74da55418"], "metadata": {"model_name": "vellino"}}, "wagner_medium": {"node_ids": ["a1dcec0e-5cf2-4341-b301-8a9c7369da94"], "metadata": {"model_name": "wagner"}}, "word_design_medium": {"node_ids": ["37e39dc9-9f16-4d66-a963-7a8e8ad30791"], "metadata": {"model_name": "word_design"}}}}