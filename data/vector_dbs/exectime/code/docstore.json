{"docstore/metadata": {"knapsack_source_code": {"doc_hash": "84fffb7199872c6234d84c5d3154a8e2bd820db1360f9f7324dee7244a0a3c8b"}, "lam_source_code": {"doc_hash": "8a48629a5d30aa25ab201c87d4df80d977d4a83edc4be903db8a9bb1be644134"}, "low_autocorrel_source_code": {"doc_hash": "a676b915d267bed3fd55c6fe1ff8a6b5257e043fd15329681dc765ca96005f98"}, "magic_hexagon_source_code": {"doc_hash": "234fe767bb10337dbe7ed932f75094a4b1cb1c532d85d74ab3aa71a911848e82"}, "ppp_source_code": {"doc_hash": "da277ddcd227122d49a5951d468745d9d7aa06ad3ec63195754f922bfde861c2"}, "rag_config_source_code": {"doc_hash": "0f59934415575366638d5047b878e6c9ec7ff6b0a19d9afe7f531fe39790a2bc"}, "ramsey_source_code": {"doc_hash": "84c3465024b7f804dac297df13ba3d350aa65ed9a1b35c346d64d803ba400026"}, "vellino_source_code": {"doc_hash": "dcd72e5ea3240ccbeb6771c81e60d28fa8cae27134883c826071c37d96c4f053"}, "wagner_source_code": {"doc_hash": "48522246939ba023213c672aaf4fe2696ac0214946e0d046fbcddfab43f74975"}, "word_design_source_code": {"doc_hash": "2435f38c3b39afb45c209bcfbfa898c537a98e52bc1be3a46f8404a92ceb5525"}, "826a6f22-2611-450d-8f90-e37e3400b951": {"doc_hash": "84fffb7199872c6234d84c5d3154a8e2bd820db1360f9f7324dee7244a0a3c8b", "ref_doc_id": "knapsack_source_code"}, "5147ac21-8b83-4c2d-8940-c7575c21468c": {"doc_hash": "63f768715533c94291b18f845d2b72d8832cdcaa1f3ca9b151480c7196b62c7d", "ref_doc_id": "lam_source_code"}, "db68ae66-326a-49e3-a913-4bd6a847fded": {"doc_hash": "a676b915d267bed3fd55c6fe1ff8a6b5257e043fd15329681dc765ca96005f98", "ref_doc_id": "low_autocorrel_source_code"}, "bd8f4d0f-afc3-464c-b367-8946ecd5372c": {"doc_hash": "234fe767bb10337dbe7ed932f75094a4b1cb1c532d85d74ab3aa71a911848e82", "ref_doc_id": "magic_hexagon_source_code"}, "c485beea-e612-4814-99f9-5945f4b0369d": {"doc_hash": "da277ddcd227122d49a5951d468745d9d7aa06ad3ec63195754f922bfde861c2", "ref_doc_id": "ppp_source_code"}, "44c38fed-6c22-4ebe-bf20-c4c21a556636": {"doc_hash": "0f59934415575366638d5047b878e6c9ec7ff6b0a19d9afe7f531fe39790a2bc", "ref_doc_id": "rag_config_source_code"}, "062b5486-04b5-4a71-a2c7-aaa0e9a89883": {"doc_hash": "84c3465024b7f804dac297df13ba3d350aa65ed9a1b35c346d64d803ba400026", "ref_doc_id": "ramsey_source_code"}, "0347cda8-8916-46bd-93be-079442c1d3d1": {"doc_hash": "dcd72e5ea3240ccbeb6771c81e60d28fa8cae27134883c826071c37d96c4f053", "ref_doc_id": "vellino_source_code"}, "c3d23af5-06b5-4304-81ed-55794cf9f268": {"doc_hash": "48522246939ba023213c672aaf4fe2696ac0214946e0d046fbcddfab43f74975", "ref_doc_id": "wagner_source_code"}, "e3028113-a069-4987-9eb5-d92d640021d1": {"doc_hash": "2435f38c3b39afb45c209bcfbfa898c537a98e52bc1be3a46f8404a92ceb5525", "ref_doc_id": "word_design_source_code"}}, "docstore/data": {"826a6f22-2611-450d-8f90-e37e3400b951": {"__data__": {"id_": "826a6f22-2611-450d-8f90-e37e3400b951", "embedding": null, "metadata": {"model_name": "knapsack"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "knapsack_source_code", "node_type": "4", "metadata": {"model_name": "knapsack"}, "hash": "84fffb7199872c6234d84c5d3154a8e2bd820db1360f9f7324dee7244a0a3c8b", "class_name": "RelatedNodeInfo"}}, "text": "language Essence 1.3\n$ prob133.essence: Knapsack Problem\n \ngiven items new type enum\ngiven weight, gain : function (total) items --> int\ngiven capacity : int\nfind picked : set of items\nmaximising sum i in picked . gain(i)\nsuch that (sum i in picked . weight(i)) <= capacity", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 273, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5147ac21-8b83-4c2d-8940-c7575c21468c": {"__data__": {"id_": "5147ac21-8b83-4c2d-8940-c7575c21468c", "embedding": null, "metadata": {"model_name": "lam"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "lam_source_code", "node_type": "4", "metadata": {"model_name": "lam"}, "hash": "8a48629a5d30aa25ab201c87d4df80d977d4a83edc4be903db8a9bb1be644134", "class_name": "RelatedNodeInfo"}}, "text": "language Essence 1.3\n$ prob025.essence: Lam's Problem\n$ Problem details available at http://www.csplib.org/Problems/prob025/\n \ngiven indexSize: int\n \nletting Index be new type of size indexSize\n \nfind m: matrix indexed by [Index,Index] of bool\n \nsuch that\n    forAll r : Index\n        . (sum c : Index . toInt(!m[r,c])) = 11,\n    forAll c : Index\n        . (sum r : Index . toInt(!m[r,c])) = 11,\n    forAll r1,r2 : Index , r1 != r2\n        . (sum c : Index . toInt(!(m[r1,c] \\/ m[r2,c]))) = 1", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 492, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "db68ae66-326a-49e3-a913-4bd6a847fded": {"__data__": {"id_": "db68ae66-326a-49e3-a913-4bd6a847fded", "embedding": null, "metadata": {"model_name": "low_autocorrel"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "low_autocorrel_source_code", "node_type": "4", "metadata": {"model_name": "low_autocorrel"}, "hash": "a676b915d267bed3fd55c6fe1ff8a6b5257e043fd15329681dc765ca96005f98", "class_name": "RelatedNodeInfo"}}, "text": "language Essence 1.3\n$ prob005.essence: Low Autocorrellation Binary Sequences\n$ Problem details available at http://www.csplib.org/Problems/prob005/\n \ngiven n : int(1..)\n \nfind seq : function (total) int(1..n) --> int(-1,1)\n \nminimising sum k : int(1..n) . (sum i : int(1..n-k) . seq(i) * seq(i+k)) ** 2", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 303, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bd8f4d0f-afc3-464c-b367-8946ecd5372c": {"__data__": {"id_": "bd8f4d0f-afc3-464c-b367-8946ecd5372c", "embedding": null, "metadata": {"model_name": "magic_hexagon"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "magic_hexagon_source_code", "node_type": "4", "metadata": {"model_name": "magic_hexagon"}, "hash": "234fe767bb10337dbe7ed932f75094a4b1cb1c532d85d74ab3aa71a911848e82", "class_name": "RelatedNodeInfo"}}, "text": "language ESSENCE 1.2.0\n$ prob023.essence: Magic Hexagon\n$ Problem details available at http://www.csplib.org/Problems/prob023/\n$ 03 September 2007\n$\n \n$ d: the diameter of the hexagon (length of the longest row)\ngiven d : int(1..)\n \n$ d must be an odd integer\nwhere d % 2 = 1\n \n$ o: the order of the hexagon (length of the shortest row)\n$ maxval: the maximum value that will appear in the hexagon\n$ maxsum: the maximum value that a row could sum to\n$ Value: the domain consisting of the integers contained in the hexagon\nletting o be d/2 + 1,\n        maxval be 3 * o**2 - 3 * o + 1,\n        maxsum be sum i : int(maxval + 1 - d..maxval) . i,\n        Value be domain int(1..maxval)\n \n$ hexagon: the hexagon is represented by a matrix. for any row i, we are only\n$          interested in the first d - |d/2 + 1 - i| elements of the row\n$ s: the magic number that all rows and diagonals sum to\nfind hexagon : matrix indexed by [int(1..d),int(1..d)] of Value,\n     s : int(1..maxsum)\n \nsuch that\n$ all elements are different (and therefore all values are included)\n    forAll r1,r2 : int(1..d) . forAll i1 : int(1..d - |o - r1|) .\n        forAll i2 : int(1..d - |o - r2|) . r1 != r2 \\/ i1 != i2 ->\n            hexagon[r1,i1] != hexagon[r2,i2],\n$ all rows sum to s\n    forAll r : int(1..d) . (sum i : int(1..d - |o - r|) . hexagon[r,i]) = s,\n$ all right-sloping diagonals sum to s\n    forAll r : int(1..d) . (sum i : int(1..d - |o - r|) .\n        hexagon[i + max({0,o-r}), r - max({0,o-(i + max({0,o-r}))})]) = s,\n$ all left-sloping diagonals sum to s\n    forAll r : int(1..d) . (sum i : int(1..d - |o - r|) .\n        hexagon[i + max({0,r-o}), r - max({0,(i + max({0,r-o}))-o})]) = s", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1678, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c485beea-e612-4814-99f9-5945f4b0369d": {"__data__": {"id_": "c485beea-e612-4814-99f9-5945f4b0369d", "embedding": null, "metadata": {"model_name": "ppp"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ppp_source_code", "node_type": "4", "metadata": {"model_name": "ppp"}, "hash": "da277ddcd227122d49a5951d468745d9d7aa06ad3ec63195754f922bfde861c2", "class_name": "RelatedNodeInfo"}}, "text": "language Essence 1.3\n$ prob013.essence: Progressive Party Problem\n$ Problem details available at http://www.csplib.org/Problems/prob013/\n \ngiven n_boats, n_periods : int(1..)\n \nletting Boat be domain int(1..n_boats)\n \ngiven capacity, crew : function (total) Boat --> int(1..)\n \nfind hosts : set (minSize 1) of Boat,\n     sched : set (size n_periods) of partition from Boat\n \nminimising |hosts|\n \n$ Hosts remain the same throughout the schedule\nsuch that\n    forAll p in sched . |parts(p)| = |hosts| /\\\n    forAll part in parts(p) . |part intersect hosts| = 1\n \n$ Hosts have the capacity to support the visiting crews\nsuch that forAll p in sched . forAll h in hosts .\n    (sum b in party(h,p) . crew(b)) <= capacity(h)\n \nsuch that allDiff([ (i, j)\n                  | p <- sched\n                  , part <- p\n                  , {i,j} <- powerSet(part)\n                  ])", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 872, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "44c38fed-6c22-4ebe-bf20-c4c21a556636": {"__data__": {"id_": "44c38fed-6c22-4ebe-bf20-c4c21a556636", "embedding": null, "metadata": {"model_name": "rag_config"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "rag_config_source_code", "node_type": "4", "metadata": {"model_name": "rag_config"}, "hash": "0f59934415575366638d5047b878e6c9ec7ff6b0a19d9afe7f531fe39790a2bc", "class_name": "RelatedNodeInfo"}}, "text": "language Essence 1.3\n$ prob031.essence: Rack Configuration Problem\n$ Problem details available at http://www.csplib.org/Problems/prob031/\n \n$ We are using the problem description from the following paper very closely here.\n$ \"Symmetry Breaking in a Rack Configuration Problem\" Zeynep K\u0131z\u0131ltan and Brahim Hnich\n \n \n \n$ The rack configuration problem consists of plugging a set of electronic cards\n$ into racks with electronic connectors.\ngiven nbRacks : int(1..)\nletting Rack be new type of size nbRacks\n \n$ Each card belongs to a certain card type.\ngiven nbTypes : int(1..)\nletting Type be domain int(1..nbTypes)\n \n$ A card type is characterised by the power it requires, ...\ngiven requiredPower : function (total) Type --> int(1..)\n \n$ ... and a demand, which designates how many cards of that type have to be plugged.\ngiven demand : function (total) Type --> int(1..)\n \n \n$ In order to plug a card into a rack, the rack needs to use a rack model.\ngiven nbModels : int\nletting Model be domain int(1..nbModels)\n \n$ Each rack model is characterised by the maximal power it can supply, its number of connectors, and its price.\ngiven maxPower      : function (total) Model --> int(1..)\ngiven maxConnectors : function (total) Model --> int(1..)\ngiven price         : function (total) Model --> int(1..)\n \n$ A rack model can be used by any rack.\n$ Each card plugged into a rack uses a connector.\n$ The problem is to decide how many of the available racks are needed,\n$ and which rack models the racks use in order to plug all the cards\n$ such that the total price is minimised.\n \nfind configuration :\n        function Rack -->\n            $ the model for this rack\n            ( Model\n            $ for each type, the number of cards of that type\n            , function (total) Type --> int(0..max(range(maxConnectors)))\n            )\n \n \n$ The constraints of the problem and the cost function can be summarised as the following:\n \n$ The connector-capacity constraint:\n$ the number of cards plugged into a rack r\n$ must not exceed the number of connectors of the rack model used by r.\nsuch that\n    forAll (rack, (model, counts)) in configuration .\n        sum([ num | (ty, num) <- counts ]) <= maxConnectors(model)\n \n$ The power-capacity constraint:\n$ the total power of the cards plugged into a rack r\n$ must not exceed the power of the rack model used by r.\nsuch that\n    forAll (rack, (model, counts)) in configuration .\n        sum([ requiredPower(ty) * num | (ty, num) <- counts ]) <= maxPower(model)\n \n$ The demand constraint: all the cards have to be plugged into some rack.\nsuch that\n    forAll (ty, tyDemand) in demand .\n        tyDemand <= sum([ num\n                        | (rack, (model, counts)) <- configuration\n                        , (ty2, num) <- counts\n                        , ty = ty2\n                        ])\n \n$ The cost function is the sum of the prices of the rack models used by all the racks needed.\nfind totalCost : int(0.. |Rack| * |Model| * max(range(price)) )\nsuch that totalCost = sum (rack, (model, counts)) in configuration . price(model)\nminimising totalCost", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3094, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "062b5486-04b5-4a71-a2c7-aaa0e9a89883": {"__data__": {"id_": "062b5486-04b5-4a71-a2c7-aaa0e9a89883", "embedding": null, "metadata": {"model_name": "ramsey"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ramsey_source_code", "node_type": "4", "metadata": {"model_name": "ramsey"}, "hash": "84c3465024b7f804dac297df13ba3d350aa65ed9a1b35c346d64d803ba400026", "class_name": "RelatedNodeInfo"}}, "text": "language Essence 1.3\n \n$ The Ramsey number R(k,l) is the smallest number such that\n$ if we two-colour the edges of complete graph of this size,\n$ there always exists a monochromatic subgraph of either k or l nodes.\n \n$ In other words (from Wikipedia):\n$ The Ramsey number, R(k,l), gives the solution to the party problem,\n$ which asks the minimum number of guests, R(k,l), that must be invited\n$ so that at least k will know each other\n$      or at least l will not know each other.\n \n$ Here, we are modelling the Ramsey-graph problem which is the problem of finding counter-examples.\n$ For a given k,l, and num_vertices: find a colouring of the complete graph\n$ which does not have a blue-subgraph nor a red-subgraph.\n \ngiven k, l, num_vertices : int\n \n$ due to symmetry R(k, l) = R(l,k)\nwhere k <= l\n \n$ complete graph, to we can calculate the number of edges\nletting num_edges be num_vertices * (num_vertices - 1)\n \n$ we are two-colouring\nletting Colour be new type enum {red, blue}\n \nletting Vertex be domain int(1..num_vertices)\n \nfind graph : function (size num_edges) (Vertex, Vertex) --> Colour\n \n \n$ the graph is complete\nsuch that\n    forAll i,j : Vertex . i < j ->\n        (i,j) in defined(graph) /\\ graph((i,j)) = graph((j,i)),\n    forAll i : Vertex .\n        !((i,i) in defined(graph))\n \n \n$ there isn't a red-subgraph of size k\nsuch that\n    forAll subgraph_vertices : set (size k) of Vertex .\n        !(forAll {i,j} subsetEq subgraph_vertices . graph((i,j)) = red)\n \n \n$ there isn't a blue-subgraph of size l\nsuch that\n    forAll subgraph_vertices : set (size l) of Vertex .\n        !(forAll {i,j} subsetEq subgraph_vertices . graph((i,j)) = blue)", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1662, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0347cda8-8916-46bd-93be-079442c1d3d1": {"__data__": {"id_": "0347cda8-8916-46bd-93be-079442c1d3d1", "embedding": null, "metadata": {"model_name": "vellino"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "vellino_source_code", "node_type": "4", "metadata": {"model_name": "vellino"}, "hash": "dcd72e5ea3240ccbeb6771c81e60d28fa8cae27134883c826071c37d96c4f053", "class_name": "RelatedNodeInfo"}}, "text": "language ESSENCE 1.2.0\n$ prob116.essence: Vellino's Problem\n$ Problem details available in:\n$   The OPL Optimization Programming Language\n$   Pascal Van Hentenryck\n$   MIT Press, January 1999.\n$\n$ 27 July 2007\n$\n \ngiven maxMaterial : int\n \n$ Material: there are five different types of materials\n$ Colour: there are three different types of bin, distinguished by colour\nletting Material be new type enum {glass,plastic,steel,wood,copper},\n        Colour be new type enum {red,green,blue}\n \n$ quantity: the amount of each material that is required to be placed in bins\n$ capacity: each bin type (colour) has a certain capacity\ngiven quantity : function (total) Material --> int(0..),\n      capacity : function (total) Colour --> int(0..)\n \n$ Bin: bins are represented by an unnamed type. the number of values is the same\n$      as the total amount of material that is required\nletting Bin be new type of size (sum m : Material . quantity(m))\n \n$ colour: each bin is assigned a colour\n$ contents: the contents of each bin is a multiset of materials\nfind colour : function Bin --> Colour,\n     $ The size of each mset returned by contents is <= some value returned by capacity (given)\n     contents : function Bin --> mset (maxOccur maxMaterial, maxSize max(range(capacity))) of Material\n \n$ minimise the number of bins that have colours & materials assigned to them\nminimising |defined(colour)|\n \nsuch that\n$ every bin that has a colour, must also have a contents, and vice versa\n    forAll b : Bin . b in defined(colour) <-> b in defined(contents),\n$ the correct amount of each material is spread across all the bins\n    forAll m : Material . (sum b in defined(contents) . freq(contents(b),m))\n                          = quantity(m),\n$ the amount of material in each bin does not exceed its capacity\n    forAll b in defined(colour) . |contents(b)| <= capacity(colour(b)),\n$ red bins cannot contain plastic or steel\n    forAll b in defined(colour) . colour(b) = red ->\n                                   !(plastic in contents(b)) /\\\n                                   !(steel in contents(b)),\n$ blue bins cannot contain wood or plastic\n    forAll b in defined(colour) . colour(b) = blue ->\n                                   !(wood in contents(b)) /\\\n                                   !(plastic in contents(b)),\n$ green bins cannot contain steel or glass\n    forAll b in defined(colour) . colour(b) = green ->\n                                   !(steel in contents(b)) /\\\n                                   !(glass in contents(b)),\n$ red bins contain at most one wooden component\n    forAll b in defined(colour) . colour(b) = red ->\n                                   freq(contents(b),wood) <= 1,\n$ green bins contain at most two wooden components\n    forAll b in defined(colour) . colour(b) = green ->\n                                   freq(contents(b),wood) <= 2,\n$ wood requires plastic\n    forAll b in defined(colour) . wood in contents(b) ->\n                                   plastic in contents(b),\n$ glass excludes copper\n    forAll b in defined(colour) . glass in contents(b) ->\n                                   !(copper in contents(b)),\n$ copper excludes plastic\n    forAll b in defined(colour) . copper in contents(b) ->\n                                   !(plastic in contents(b))", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3295, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c3d23af5-06b5-4304-81ed-55794cf9f268": {"__data__": {"id_": "c3d23af5-06b5-4304-81ed-55794cf9f268", "embedding": null, "metadata": {"model_name": "wagner"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "wagner_source_code", "node_type": "4", "metadata": {"model_name": "wagner"}, "hash": "48522246939ba023213c672aaf4fe2696ac0214946e0d046fbcddfab43f74975", "class_name": "RelatedNodeInfo"}}, "text": "language Essence 1.3\n \n$ ** Updates **\n$ 2021/08/04 - The new model 'DistributionWagnerWhitin-partialfunc.essence' performances\n$              signficantly better in practice.\n \n$ Problem Wagner-Whitin Distribution\n$\n$ Problem details available at http://www.csplib.org/Problems/prob040/\n$\n$ Essence model by Andrew Martin\n$\n$ Licenced under CC-BY-4.0 : http://creativecommons.org/licenses/by/4.0/\n \n$ in this model, rather than define multiple levels, children of each node are defined explicitly\n \ngiven numNodes : int(1..)\n \n$ leaves are always first numLeaves nodes\n$ leaves cannot have any children\ngiven numLeaves : int(1..)\n \n$ period 0 is empty, all stock is 0\ngiven numPeriods : int(1..)\n \n$ used to provide bound to output\ngiven maxStock : int(1..)\n \nletting dNodes be domain int(1..numNodes)\nletting dLeaves be domain int(1..numLeaves)\nletting dAllPeriods be domain int(0..numPeriods)\nletting dPeriods be domain int(1..numPeriods)\n \ngiven holdingCost : matrix indexed by [dNodes] of int(0..)\n \ngiven procCost : matrix indexed by [dNodes] of int(0..)\n \ngiven demand : matrix indexed by [dLeaves, dPeriods] of int(0..)\n \n$ used to determine where supply comes goes to\ngiven children : matrix indexed by [dNodes] of set of dNodes\n \nfind orders : matrix indexed by [dNodes, dPeriods] of int(0..maxStock)\n \n$ AUX find statement\nfind stock : matrix indexed by [dNodes, dAllPeriods] of int(0..maxStock)\n \n$ minimising the cost\n$ holding*stock per period per node plus proc if any orders were placed per period per node\nminimising (sum t : dPeriods . (sum i : dNodes . (holdingCost[i] * stock[i][t] + procCost[i] * toInt(orders[i][t] > 0))))\n \n \nsuch that\n \n$ stock starts at 0\n    forAll i : dNodes .\n        stock[i][0] = 0\n,\n$ non-leaf constraints - orders coming from children must be fulfilled\n    forAll t : dPeriods .\n        forAll i : int(numLeaves+1..numNodes) .\n            stock[i][t] = stock[i][t-1] + orders[i][t] - (sum m in children[i] . orders[m][t])\n,\n$ leaf constraints - demands must be fullfilled\n    forAll t : dPeriods .\n        forAll i : dLeaves .\n            stock[i][t] = stock[i][t-1] + orders[i][t] - demand[i][t]", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2145, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e3028113-a069-4987-9eb5-d92d640021d1": {"__data__": {"id_": "e3028113-a069-4987-9eb5-d92d640021d1", "embedding": null, "metadata": {"model_name": "word_design"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "word_design_source_code", "node_type": "4", "metadata": {"model_name": "word_design"}, "hash": "2435f38c3b39afb45c209bcfbfa898c537a98e52bc1be3a46f8404a92ceb5525", "class_name": "RelatedNodeInfo"}}, "text": "language Essence 1.3\n$ prob033.essence: Word Design for DNA Computing on Surfaces\n$ Problem details available at http://www.csplib.org/Problems/prob033/\n \nletting Base be new type enum {A,C,G,T},\n        Index be domain int(1..8)\n \n$ Notice: The problem specification states that we are trying to find a set of words.\n$ We take this literally, and do not allow repeated words.\n \nfind words : set of function (total) Index --> Base\n \nmaximising |words|\n \nsuch that\n \n    $ Each word in S has 4 symbols from (C, G)\n    forAll w in words . |preImage(w,C)| + |preImage(w,G)| = 4,\n \n    $ Each pair of words in S differ in at least 4 positions\n    forAll {w1,w2} subsetEq words .\n        (sum i : Index . toInt(w1(i) != w2(i))) >= 4,\n \n    forAll {w1,w2} subsetEq words .\n        (sum i : Index .\n            $\n            $ To decide whether they are identical at index i, we need to inspect the values of w1(9-i) and w2(i).\n            $ This is because w1 is reversed, and w2 is the Watson-Crick complement.\n            $\n            $ Watson-Crick complementing is implemented by listing a set of allowed pairs.\n            $ If the pair is a member of the set of allowed pairs, they are identical.\n            $\n            $ We require that they are not identical (hence the negation) in at least 4 positions.\n            $\n            toInt(! ((w1(9-i), w2(i)) in {(A,T), (C,G), (G,C), (T,A)}) )\n        ) >= 4", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1412, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"knapsack_source_code": {"node_ids": ["826a6f22-2611-450d-8f90-e37e3400b951"], "metadata": {"model_name": "knapsack"}}, "lam_source_code": {"node_ids": ["5147ac21-8b83-4c2d-8940-c7575c21468c"], "metadata": {"model_name": "lam"}}, "low_autocorrel_source_code": {"node_ids": ["db68ae66-326a-49e3-a913-4bd6a847fded"], "metadata": {"model_name": "low_autocorrel"}}, "magic_hexagon_source_code": {"node_ids": ["bd8f4d0f-afc3-464c-b367-8946ecd5372c"], "metadata": {"model_name": "magic_hexagon"}}, "ppp_source_code": {"node_ids": ["c485beea-e612-4814-99f9-5945f4b0369d"], "metadata": {"model_name": "ppp"}}, "rag_config_source_code": {"node_ids": ["44c38fed-6c22-4ebe-bf20-c4c21a556636"], "metadata": {"model_name": "rag_config"}}, "ramsey_source_code": {"node_ids": ["062b5486-04b5-4a71-a2c7-aaa0e9a89883"], "metadata": {"model_name": "ramsey"}}, "vellino_source_code": {"node_ids": ["0347cda8-8916-46bd-93be-079442c1d3d1"], "metadata": {"model_name": "vellino"}}, "wagner_source_code": {"node_ids": ["c3d23af5-06b5-4304-81ed-55794cf9f268"], "metadata": {"model_name": "wagner"}}, "word_design_source_code": {"node_ids": ["e3028113-a069-4987-9eb5-d92d640021d1"], "metadata": {"model_name": "word_design"}}}}